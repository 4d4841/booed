<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="mg-common-styles.html">

<dom-module id="mg-color-picker">
<template strip-whitespace>
    <custom-style>
  <style is="custom-style" include="mg-common-styles iron-flex iron-flex-alignment">

  :host {
    display: block;
    position: relative;
    @apply --layout-vertical;
    @apply --layout-center;
    @apply --layout-center-justified;
    overflow: hidden;
    background-color: hsl(180,50%,50%);
  }

  iron-icon {
    color: rgba(0,0,0,0.3);
    transition: color 0.25s;
    pointer-events: none;
    position:absolute;
    --iron-icon-width: 22px;
    --iron-icon-height: 22px;
  }

  </style>
    </custom-style>

    <template is="dom-repeat" items="[[c]]">
      <iron-icon style$="[[_formatIconStyleForC(c,mouseIn,tracking,iconMode,index)]]" icon="[[_formatIconForMode(index)]]"></iron-icon>
    </template>

</template>
<script>
class MGColorPicker extends Polymer.GestureEventListeners(
  Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element)
) {

  static get is() { return 'mg-color-picker'; }

  _formatIconForMode(mode) {
    return ["image:looks","invert-colors","image:brightness-6"][mode];
  }

  static get properties() { return {
    value: {
      type: String,
      notify: true,
      observer: '_valueChanged',
    },
    mode: {
      type: Number,
      value: 0,
      observer: '_modeChanged'
    },
    componentType: {
      type: String,
      observer: '_componentTypeChanged',
      notify: true,
    },
    c: {
      type: Array,
      observer: '_colorChanged',
      value: function(){return [null];},
    },
  }}

  static get observers() { return [
  ]}

  _componentTypeChanged(type) {
    switch(type) {
      case 'hsl': {
        this.set('c',[0.5,0.5,0.5]);
      }
    }
  }

  _modeChanged(mode) {
    this._delayChangeDebouncer = Polymer.Debouncer.debounce(this._delayChangeDebouncer,
      Polymer.Async.timeOut.after(50), () => {
        this.set('iconMode',mode);
      });
  }

  _formatIconStyleForC(c,mouseIn,tracking,mode,match) {
    if (mode !== match) return 'color:transparent';
    c = c || [0.5,0.5,0.5];
    switch(this.componentType) {
      case 'hsl': {
        let col = c[2] > 0.3 ? 20 : 220;
        let alpha = 0.3;
        if (mouseIn || tracking) {
          alpha = 1.0;
        }
        return `color:rgba(${col},${col},${col},${alpha})`;
      }
    }
    return "";
  }

  _colorChanged(c) {
    if (c[0] === null) {
      return;
    }
    let cc = [];
    switch(this.componentType) {
      case 'hsl':
        cc[0] = (Math.round(c[0]*360)%360 + 360)%360;
        c[1] = c[1] < 0 ? 0 : c[1] > 1 ? 1 : c[1];
        cc[1] = c[1] * 100;
        c[2] = c[2] < 0 ? 0 : c[2] > 1 ? 1 : c[2];
        cc[2] = c[2] * 100;
        this.set('value',`hsl(${Math.round(cc[0])},${Math.round(cc[1])}%,${Math.round(cc[2])}%)`);
        break;
    }
  }

  _valueChanged(v) {
    if (!v) {
      v = 'rgba(0.5,0.5,0.5,1)';
    }
    this.style.backgroundColor = v;
  }

  connectedCallback(){
    super.connectedCallback();
    Polymer.Gestures.addListener(this, 'track', e => this._onTrack(e));
    Polymer.Gestures.addListener(this, 'tap', e => {
      console.log('clock');
      let l = this.c.length;
      this.set('mode', ((this.mode+1)%l + l)%l);
    });

    this.addEventListener('mouseenter', e => {
      if (!e.buttons) {
        this.set('mouseIn',true);
        if (this._delayFadeDebouncer) {
          this._delayFadeDebouncer.cancel();
          delete this._delayFadeDebouncer;
        }
      }
    },true);

    this.addEventListener('mouseout', e => {
      this._delayFadeDebouncer = Polymer.Debouncer.debounce(this._delayFadeDebouncer,
        Polymer.Async.timeOut.after(1000), () => {
          if (!this.tracking)
            this.set('mouseIn',false);
        });

    },true);
  }

  _onTrack(e) {
    e.preventDefault();
    let viewBB = this.getBoundingClientRect();
    let cw = this.clientWidth * 2;
    let ch = this.clientHeight * 2;
    let ax = (e.detail.x - viewBB.left) / cw;
    let ay = (e.detail.y - viewBB.top) / ch;
    let ddx = e.detail.ddx / cw;
    let ddy = e.detail.ddy / ch;

    switch (e.detail.state) {
      case 'start':
        if(!this.c) {
          this.set('c',[0.5,0.5,0.5]);
        }
        /* Hack to prevent tracking locked into some kind of drag mode with a double-clicking */

        this.set('tracking', {
          ox: ax,
          oy: ay,
          ax: ax,
          ay: ay,
          c:[this.c[0],this.c[1],this.c[2]],
          axis: '',
          mode: this.mode,
        });

        break;
      case 'end': {
        /*
        if (Math.abs(ax - this.tracking.ox) < 5/cw && Math.abs(ay - this.tracking.oy) < 5/ch) {
          let l = this.c.length;
          this.set('mode', ((this.mode+1)%l + l)%l);
        }
        */
        this.set('tracking',null);
        this._delayFadeDebouncer = Polymer.Debouncer.debounce(this._delayFadeDebouncer,
          Polymer.Async.timeOut.after(1000), () => {
            this.set('mouseIn',false);
          });

      } break;
      case 'track': {
        let dy = ay - this.tracking.ay;
        let dx = ax - this.tracking.ax;

        if (this.tracking.axis != 'y' && Math.abs(dy) > 10/ch) {
          this.tracking.axis = 'y';
          this.tracking.ax = ax;
        }

        if (this.tracking.axis != 'x' && Math.abs(dx) > 10/cw) {
          this.tracking.axis = 'x';
          this.tracking.ay = ay;
        }

        if (!this.tracking.axis) {
          break;
        }

        if (this.tracking.axis == 'y') {
          let l = this.c.length;
          let m = (Math.round(this.tracking.mode+dy)%l + l)%l;

          if (m != this.tracking.mode) {
            this.set('mode',m);
            this.tracking.mode = m;
            this.tracking.ay = ay;
          }

        } else /* x */ {
          let cc = [].concat(this.c);
          cc[this.mode] += ddx/2;
          this.set('c',cc);

        }

        if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
          this.tracking.ax = ax;
          this.tracking.ay = ay;
        }

      } break;
    }
  }
}

customElements.define(MGColorPicker.is, MGColorPicker);

</script>
</dom-module>
