<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="mg-item-editor.html">
<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-input.html">
<link rel="import" href="mg-item-image.html">
<link rel="import" href="mg-image-editor.html">


<dom-module id="mg-gallery-editor">
  <template strip-whitespace>
      <custom-style>
    <style is="custom-style" include="mg-common-styles iron-flex iron-flex-alignment">
      :host {
        min-height: 80vh;
        background-size: contain;
        background-repeat: no-repeat;
      }

      :host([empty]) {
        background-image: url(/images/logo-pumpkin-light.svg);
        border-radius: 5px;
      }

      .file-item {
        width: 100%;
        position: relative;
      }

      #image-selector {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        padding: 0px;
        height: 100%;
      }

      /*
      .cancel-copy-button {
        @apply(--layout-self-end);
        color:white;
        --iron-icon-stroke-color:rgba(0,0,0,0.2);
        pointer-events: none;
      }
      */

      .image-icon {
        margin: 0 5px 5px 0;
        width: 120px;
        height: 120px;
      }

    </style>
      </custom-style>

    <iron-collapse class="vertical layout" opened="[[itemKey]]">

      <div id="gallery-editor" class="horizontal layout end wrap">

            <div style="display:inline-block">
          <paper-icon-button icon="add-photo" on-tap="_onAddButtonTap"></paper-icon-button>
          <paper-tooltip>เพิ่มรูป</paper-tooltip>
            </div>

            <div style="display:inline-block">
          <paper-icon-button icon="[[copyIcon]]" on-click="_onCopyButtonTap"></paper-icon-button>
          <paper-tooltip>[[copyMethod]]</paper-tooltip>
            </div>

              <template is="dom-if" if="[[iconList.length]]">
            <div style="display:inline-block">
          <paper-icon-button icon="select-all" on-click="_onSelectAllButtonTap"></paper-icon-button>
          <paper-tooltip>เลือกหมด</paper-tooltip>
            </div>
              </template>

          <template is="dom-if" if="[[selectedImages.length]]">

              <div style="display:inline-block">
            <paper-icon-button icon="delete" on-click="_onDeleteButtonTap"></paper-icon-button>
            <paper-tooltip>ลบรูป</paper-tooltip>
              </div>

              <div style="display:inline-block">
            <paper-icon-button icon="mode-edit" on-click="_onEditButtonTap"></paper-icon-button>
            <paper-tooltip>แก้ไข</paper-tooltip>
              </div>

              <div style="display:inline-block">
            <paper-icon-button icon="reorder" on-click="_onReorderButtonTap"></paper-icon-button>
            <paper-tooltip>เรียง</paper-tooltip>
              </div>

              <div style="display:inline-block">
            <paper-icon-button icon="cancel" on-click="_onCancelButtonTap"></paper-icon-button>
            <paper-tooltip>ยกเลือกที่เลือก</paper-tooltip>
              </div>

          </template>

        <input type="file" id="fileInput" on-change="_filesSelected" hidden multiple>

      </div>

      <iron-selector
        id="image-selector"
        attr-for-selected="key"
        selected-values="{{selectedImages}}"
        multi>

      <!-- XXX Maybe sorting will cause ghost update -->
      <template is="dom-repeat" items="{{iconList}}" observe="order deleted" sort="{{_reorderPhoto}}">

        <mg-item-image
          key="[[item.key]]"
          class="image-icon"
          thumbnail="[[item.thumbnail]]"
          rep="[[item.rep]]"
          progress="[[item._progress]]"
          name="[[item.name]]"
          selection-order="[[item._selectionOrder]]"
          deleted="[[item.deleted]]"
          on-tap="_onItemTap"
        >
        <!--
          <template is="dom-if" if="{{_isEditable(item._progress,item.rep)}}">
            <paper-icon-button icon="mode-edit" class="image-edit-button-icon" on-tap="_onEditImage">
            </paper-icon-button>
          </template>
        -->
        </mg-item-image>

      </template>

      </iron-selector>

    </iron-collapse>

    <mg-image-editor
      id="image-editor"
      data="{{editingData}}"
      blob="{{blob}}"
      after="[[afterEditingData]]"
      before="[[beforeEditingData]]"
    ></mg-image-editor>

  </template>
  <script>
  (function() {
    let memoizedTemplate;

    class MGGalleryEditor extends MGItemEditor {
      static get is() { return 'mg-gallery-editor'; }

      static get template() {
        if (!memoizedTemplate) {
          memoizedTemplate = Polymer.DomModule.import(this.is, 'template');
          let superTemplateContents = document.importNode(MGItemEditor.template.content, true);
          let editor = memoizedTemplate.content.querySelector('#gallery-editor');
          let firstChild = editor.firstChild;
          editor.insertBefore(superTemplateContents, firstChild);
        }
        return memoizedTemplate;
      }

      static get properties() { return {
        itemRole: {
          type: String,
          value: "gallery",
          readOnly: true,
        },

        files: Object,

        iconList: {
          type: Array,
          value: [],
        },

        selectedImages: {
          type: Array,
          value: [],
        },

        empty: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
        },

        editingData: {
          type: Object,
          observer: '_editingDataChanged',
        },

        copyMethod: {
          type: String,
          computed: '_computeCopyMethod(selectedImages.length)'
        },

        copyIcon: {
          type: String,
          computed: '_computeCopyIcon(selectedImages.length)'
        },

      }}

      _computeCopyIcon(selectedLen) {
        return selectedLen ? "content-copy-selection" : "content-copy";
      }

      _computeCopyMethod(selectedLen) {
        return selectedLen ? 'ก๊อปปี้ที่เลือก' : 'ก๊อปปี้แกลเลอรี่';
      }

      static get observers() { return [
        '_selectedImagesChanged(selectedImages.splices)',
        '_checkEmpty(iconList.length)',
      ]}

      _checkEmpty(len) {
        this.set('empty', len?false:true);
      }

      _reorderPhoto(a,b) {
        if (a.deleted) {
          if (b.deleted) {
            if (a.key < b.key) {
              return -1;
            }
          }
          return 1;
        }
        if (b.deleted) {
          return -1;
        }

        if (a.order) {
          if (b.order) {
            return a.order - b.order;
          }
          return -1;
        } else if (b.order) {
          return 1;
        }

        if (a.key < b.key) {
          return -1;
        }

        return 1;
      }

      _isEditable(progress,rep) {
        if (!rep) return false;
        if (progress && progress != 100) return false;
        if (progress === 0) return false;
        return true;
      }

      _selectedImagesChanged(changes) {
        if (changes) {
          /* Remove number from deselected photo */
          changes.indexSplices.forEach(splice => {
            splice.removed.forEach(removedKey => {
              this._setPhotoKeyProperty(removedKey,'_selectionOrder',null);
            })
          });

          let orderNumber = 0;
          this.selectedImages.forEach(key => {
            this._setPhotoKeyProperty(key,'_selectionOrder',++orderNumber);
          });
        }
      }

      _onItemTap(e) {

        if (e.detail.sourceEvent.shiftKey) {
          if (typeof(this._LastTapIndex) == "undefined") {
            this._LastTapIndex = -1;
          }

          let inc = this._LastTapIndex < e.model.index ? 1 : -1;

          for (let i = this._LastTapIndex + inc; inc > 0 ? i < e.model.index : i > e.model.index; i+=inc) {
            this.$['image-selector'].selectIndex(i);
          }
        }
        this._LastTapIndex = e.model.index;
      }

      _indexImage(imageKey,cb,nacb) {
        /* XXX optimize later
        if (!this._ImageMap) {
          this._ImageMap = newMap();
        }

        let idx = this._ImageMap.get(imageKey);
        if (this.iconList.length > idx &&  this.iconList[idx].key == imageKey) {
          return idx;
        }
        */

        let i, data;
        for (i = 0; data = this.iconList[i]; ++i) {
          //this._ImageMap.set(data.key, i);
          if (data.key == imageKey) {
            if (cb) { cb(i,data); }

            return i;
          }
        }

        if (nacb) { nacb(cb);}
        return -1;
      }

      _setPhotoKeyProperty(key,prop,val) {
        let idx = this._indexImage(key);
        if (idx !== -1) {
          if (this.iconList[idx][prop] != val) {
            this.set(['iconList',idx,prop],val);
          }
        }
      }

      _uploadReps(uid,itemKey,files) {
        Array.from(files).forEach(imgFile => {
          let imageKey =  MHA.DB.ref('home').child(uid).child(itemKey).child('images').push().key;
          let imageName = imgFile.name.split('.')[0];
          let coverImageKey = MHA.get(['items',itemKey,'cover']) || imageKey;

          MHA.assignItem(itemKey,{ cover: coverImageKey });

          let registerInfo = {};
          function registerImageReps() {

            /* Update once thumbnail and rep are both uploaded onto storage */
            if (registerInfo.thumbnail && registerInfo.rep) {
              let registerData = {
                ['representations/'+registerInfo.rep+'/uid']: uid,
                ['representations/'+registerInfo.thumbnail+'/uid']: uid,
                ['home/'+uid+'/items/'+itemKey+'/cover']: coverImageKey,
                ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/thumbnail']: registerInfo.thumbnail,
                ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/rep']: registerInfo.rep,
                ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/name']: registerInfo.name,
              }
              MHA.DB.ref().update(registerData, error => {
                if (error) {
                  console.error("ERR",error);
                }
              });
            }
          }

          MHA.registerRepresentation(imgFile, {
            progress: (repKey,progress) => {
                this._setPhotoKeyProperty(imageKey, '_progress', (progress.bytesTransferred / progress.totalBytes * 100).toFixed(2));
            },
            complete: (repKey,complete) => {
              MHA.assignItem(itemKey,{
                images: {
                  [imageKey]: {
                    rep: repKey,
                  }
                },
              });

              /* This will contain customizations like ROIs, thumbnail, custom name */
              registerInfo.rep = repKey;
              registerInfo.name = imageName;
              /* Published item, Will also contain tags */
              registerImageReps();
            },
            src: (repKey,src) => {

              /* src here is e.target.result of source image file from FileReader,
               * Will use it to generate thumbnail image data.
               */

              let thumbnailLoader = new Image();
              let canvas = document.createElement('canvas');

              thumbnailLoader.onload = (e) => {
                let area = (250*250); /* Default area size for thumbnail */
                /* Try relying with data sizes rather geometries. */
                let w = Math.ceil(Math.sqrt(area * thumbnailLoader.width / thumbnailLoader.height));
                let h = Math.ceil(area / w);

                canvas.width = w;
                canvas.height = h;
                canvas.getContext('2d').drawImage(thumbnailLoader, 0, 0, w, h);
                canvas.toBlob(blob => {

                  /* Thumbnail's actual upload should start after finishing image upload */
                  MHA.registerRepresentation(blob, {
                    key: key => {

                      this.push('iconList',{
                        item: itemKey,
                        key: imageKey,
                        thumbnail: key,
                        name: imageName,
                        rep: repKey,
                        _progress: 0,
                      });

                    },
                    src: (key,src) => {
                      MHA.assignItem(itemKey,{
                        images: {
                          [imageKey]: {
                            name: imageName,
                            thumbnail: key,
                          }
                        },
                      });
                    },
                    complete: key => {
                      /* This will contain customizations like ROIs, thumbnail, custom name */
                      registerInfo.thumbnail = key;
                      /* Published item, Will also contain tags */
                      registerImageReps();
                    },
                  });

                },'image/jpeg',0.8);
              }; /* end thumbnailLoader.onload */
              thumbnailLoader.src = src;

            }

          });

        }); /*forEach(files)*/
      }

      _filesSelected(e) {
        let files = e.target.files;
        if (!files || !files.length) {
          return;
        }

        let itemKey = this.itemKey;
        let uid = MHA.AU.currentUser.uid;
        let role = this.itemRole;
        let name = this.itemName;

        console.assert(role, "Role is missing");

        MHA.assignItem(itemKey,{
            _uid: uid,
            name: name,
            role: role,
            time: firebase.database.ServerValue.TIMESTAMP,
        });

        var registerData = {};
        registerData['home/'+uid+'/items/'+itemKey+'/role'] = role;
        registerData['home/'+uid+'/items/'+itemKey+'/name'] = name;
        registerData['items/'+itemKey+'/uid'] = uid;
        registerData['items/'+itemKey+'/role'] = role;
        registerData['items/'+itemKey+'/name'] = name;
        registerData['items/'+itemKey+'/public'] = false;

        MHA.DB.ref().update(registerData, error => { if (!error) {} });

        this._uploadReps(uid,itemKey,files);
      }

      /* Set image thumbnails from global notification */
      updateChanges(path,value) {
        let itemKey = path[1];
        let itemProperty = path[2];

        switch(itemProperty) {
          case 'name': {
            this.set('itemName', this._ItemName = value);
          } break;
          case 'images': {
            let imageKey = path[3];

            switch(path.length) {
              case 4: {
                this._indexImage(imageKey,null,cb => {
                  this.push('iconList', {item:itemKey, key:imageKey});
                });
              } break;
              case 5: {
                let imageProperty = path[4];
                this._indexImage(imageKey,idx => {
                  this.set(['iconList',idx,imageProperty], value);
                });

                if (this.editingData && this.editingData.key == imageKey) {
                  /* XXX Just handle the roi for now. */
                  if (imageProperty == 'roi')
                    this.notifyPath('editingData.roi');
                }
              } break;
              default:
              break;
            }

          } break;
        }
      }

      _getDataError(error) {
        console.error("ERR", error);
        this._ItemReference.off('value', this._onItemSnapshot, this);
        delete this._ItemReference;
      }

      _itemKeyChanged(itemKey) {

        delete this._LastTapIndex;

        this.iconList.forEach((icon,index) => {
          this.set(['iconList',index,'thumbnail'],null);
        });

        this.splice('iconList',0,this.iconList.length);

        this.splice('selectedImages',0,this.selectedImages.length);

        super._itemKeyChanged(itemKey);

        let item = MHA.get('items.'+itemKey);
        for(let prop in item) {
          switch(prop) {
            case '_uid':
              break;
            case 'name':
              this.set('itemName', this._ItemName = item.name);
              break;
            case 'role':
              console.assert('gallery' == item.role, "XXX");
              break;
            case 'images': {
              let allImages = item.images;
              for (let imageKey in allImages) {
                let image = allImages[imageKey];
                let icon = {
                  item: itemKey,
                  key: imageKey,
                  thumbnail: image.thumbnail,
                  rep: image.rep,
                  name: image.name,
                  order: image.order,
                  deleted: image.deleted,
                  roi: image.roi,
                };
                this.push('iconList', icon);
              }
            } break;
            default:
          }
        }
      }

      _formatSize(bytes) {
        const base = 1024;
        const unit = ~~(Math.log(bytes) / Math.log(base));
        const dec = Math.max(0, Math.min(3, unit - 1));
        const size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
        return size + ' ' + ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'][unit];
      }

      _onAddButtonTap(e) {
        this.$.fileInput.value = '';
        this.$.fileInput.click();
      }

      _onReorderButtonTap(e) {
        let registerData = {};
        let autoNumber = this.selectedImages.length;

        this.iconList.map((item, idx) => {
          return {index: idx, order:item.order|| Number.MAX_SAFE_INTEGER};
        })
        .sort((a,b) => a.order - b.order)
        .map(item => this.iconList[item.index])
        .forEach(icon => {
            if (icon._selectionOrder == 1) {
              registerData['home/'+MHA.AU.currentUser.uid+'/items/'+this.itemKey+'/cover'] = icon.key;
            }
            registerData['home/'+MHA.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+icon.key+'/order'] = icon._selectionOrder || ++autoNumber;
        });


        MHA.DB.ref().update(registerData, error => {
          console.assert(!error,"ERR updating order");
        });
        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onDeleteButtonTap(e) {
        let registerData = {};
        let selectedImages = this.selectedImages;

        this.selectedImages.forEach(selectedKey => {
          let del = MHA.get(['items',this.itemKey,'images',selectedKey,'deleted']) ? null:true;
          MHA.assignItem(this.itemKey, {images:{[selectedKey]:{deleted:del}}});
          registerData['home/'+MHA.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+selectedKey+'/deleted'] = del;
        });
        this.splice('selectedImages',0,this.selectedImages.length);

        MHA.DB.ref().update(registerData, error => {
            console.assert(!error,"ERR updating deletion");
        });
      }

      _onSelectAllButtonTap(e) {
        for (let i = 0; i < this.iconList.length; i++) {
          this.$['image-selector'].selectIndex(i);
        }
      }

      _onCancelButtonTap(e) {
          this.splice('selectedImages',0,this.selectedImages.length);
      }

      _editingDataChanged(data) {
        this._EditingSelection = this._EditingSelection || [];
        this.set('beforeEditingData',null);
        this.set('afterEditingData',null);
        if (data) {
          let slen = this._EditingSelection.length;
          if (slen) {

            let currentIdx = this._EditingSelection.indexOf(data.key);

            if (currentIdx != -1) {
              this.set('beforeEditingData',this.iconList[this._indexImage(this._EditingSelection[(currentIdx-1+slen) % slen])]);
              this.set('afterEditingData',this.iconList[this._indexImage(this._EditingSelection[(currentIdx+1) % slen])]);
            }
          }
        } else {
          this._EditingSelection.splice(0,this._EditingSelection.length);
        }
      }


      _onEditButtonTap(e) {
        this._EditingSelection = [].concat(this.selectedImages);
        this._indexImage(this._EditingSelection[0], idx => {
          this.set('editingData',this.iconList[idx]);
        });
        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onCopyButtonTap(e) {
        if (this.selectedImages.length == 0) {
          /* Copy as gallery  */

          return;
        }

        /* Copy as image(s) */
        this.selectedImages.forEach(imageKey => {
          this._indexImage(imageKey, idx => {
            let copy = {
              role: 'image',
              name: this.iconList[idx].name,
              thumbnail: this.iconList[idx].thumbnail,
              rep: this.iconList[idx].rep,
              roi: this.iconList[idx].roi,
            };
            this.push('clipboardList',copy);
          });
        });

        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _pastedDataChanged(paste) {
        console.assert(paste.length, "Empty pasted data");

        let uid = MHA.AU.currentUser.uid;
        let itemKey = this.itemKey;
        let path = 'home/'+uid+'/items/'+itemKey;
        let ref = MHA.DB.ref('home').child(uid).child(itemKey).child('images');
        let registerData = {
          ['items/'+itemKey+'/public']: false,
          ['items/'+itemKey+'/uid']: uid,
          ['items/'+itemKey+'/role']: this.itemRole,
          ['items/'+itemKey+'/name']: this.itemName,
          [path+'/role']: this.itemRole,
          [path+'/name']: this.itemName,
        };

        path+='/images/';
        let coverKey = MHA.get(['items',itemKey,'cover']);
        let area = (250*250); /* Pixel area for creating thumbnail */
        let waitThumbnails = 0; /* waiting counter for all completions */

        paste.forEach((data,index) => {
          if (data.deleted || data.role != 'image') return;

          let imageKey = ref.push().key;
          coverKey = coverKey || imageKey;
          registerData[path+imageKey+'/name'] = data.name || null;
          registerData[path+imageKey+'/rep'] = data.rep || null;

          /* If thumbnails were virtually defined with ROIs, it bakes them first */
          if (data.roiThumbnail) {
            waitThumbnails++;
            MHA.registerRepresentation(data.rep,{src: (key,src) => {

              let imageLoader = new Image();
              imageLoader.crossOrigin="anonymous";
              imageLoader.onload = e => {
                let width = imageLoader.naturalWidth;
                let height = imageLoader.naturalHeight;

                let tl = width * data.roiThumbnail[0];
                let tt = height * data.roiThumbnail[1];
                let tw = width * data.roiThumbnail[2];
                let th = height * data.roiThumbnail[3];

                let w = Math.ceil(Math.sqrt(area * tw/th));
                let h = Math.ceil(area / w);

                let canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;

                canvas.getContext('2d').drawImage(imageLoader, tl, tt, tw, th, 0, 0, w, h);
                canvas.toBlob( thumbnailBlob => {
                  MHA.registerRepresentation( thumbnailBlob, {
                    key: thumbnailKey => {
                      /* Rather waits until upload complete, announces the
                       * instances immediately to catch up with user actions.
                       * Doing this will show empty loading thumbnails.
                       * Since it will use a returned locally stored dataURI generated
                       * from Blob it doesn't need the uploading process to complete.
                       */
                      MHA.assignItem(itemKey, {
                        images: {[imageKey]: {thumbnail: thumbnailKey, roiThumbnail: null}},
                      });
                    },
                    complete: (thumbnailKey,complete) => {
                      registerData[path+imageKey+'/thumbnail'] = thumbnailKey;

                      waitThumbnails--;
                      if (waitThumbnails == 0) {
                        MHA.DB.ref().update(registerData, error => {
                          if (!error) {
                          } else {
                            console.error("ERR",error);
                          }
                        });
                      }
                    },
                  });
                }, 'image/jpeg',0.8);
              };
              imageLoader.src = src;

            }});
            let canvas = document.createElement('canvas');



          } else {
            registerData[path+imageKey+'/thumbnail'] = data.thumbnail || null;
          }
        });

        registerData['home/'+uid+'/items/'+itemKey+'/cover'] = coverKey;

        /* XXX Should it also update local? Or should it rely only on query events? */
        /* XXX Need to try off-line. */

        if (waitThumbnails == 0) {
          MHA.DB.ref().update(registerData, error => {
            if (!error) {
            } else {
              console.error("ERR",error);
            }
          });
        }
      }

      _onEditImage(e) {
        let data = e.model.item;
        this.set('editingData',data);
        e.stopImmediatePropagation();
      }

    }

    customElements.define(MGGalleryEditor.is, MGGalleryEditor);
  })();
  </script>
</dom-module>
