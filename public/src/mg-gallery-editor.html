<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="mg-clipboard.html">
<link rel="import" href="mg-item-editor.html">
<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-input.html">
<link rel="import" href="mg-item-image.html">
<link rel="import" href="mg-image-editor.html">

<dom-module id="mg-gallery-editor">
<template strip-whitespace>
    <custom-style>
  <style is="custom-style" include="mg-item-editor mg-common-styles iron-flex iron-flex-alignment">

    #image-selector {
      @apply --layout-horizontal;
      @apply --layout-wrap;
      @apply --layout-flex;
      @apply --layout-start-aligned;
      padding: 0 0 24px 0;
      overflow-y: auto;
      border: 1px solid transparent;
      border-radius: 5px;
      margin: 0 20px 50px 0;
    }

    :host([empty]) #image-selector {
      border: 1px dashed var(--disabled-text-color);
    }

    :host([dropenter]) #image-selector {
      border: 1px dashed tomato;
    }

    #gallery-editor {
    }

    .image-icon {
      margin: 0 5px 5px 0;
      --mg-image: {
        width: 120px;
        height: 120px;
      }
    }

    @media (max-width: 767px) {
      #image-selector {
        padding: 0;
      }

      #gallery-editor {
        padding-bottom: 15px;
      }

    }
  </style>
    </custom-style>

  <mg-clipboard clipboard-list="{{clipboardList}}"></mg-clipboard>

  <div id="gallery-editor" ondrop="_onDrop" class="vertical layout" hidden$="[[!itemKey]]">

    <div id="control-panel" class="horizontal layout wrap end" >
      <div style="display:inline-block">
    <paper-icon-button icon="booed:add-photo" on-tap="_onAddButtonTap"></paper-icon-button>
    <paper-tooltip>เพิ่มรูป</paper-tooltip>
      </div>

      <div style="display:inline-block">
    <paper-icon-button icon="[[copyIcon]]" on-click="_onCopyButtonTap"></paper-icon-button>
    <paper-tooltip>[[copyMethod]]</paper-tooltip>
      </div>

      <div style="display:inline-block">
    <paper-icon-button disabled="[[!clipboardList.length]]" icon="content-paste" on-click="_onPasteButtonTap"></paper-icon-button>
    <paper-tooltip>แปะ</paper-tooltip>
      </div>

      <div style="display:inline-block">
    <paper-icon-button disabled="[[!clipboardList.length]]" icon="booed:content-clear" on-click="_onClearButtonTap"></paper-icon-button>
    <paper-tooltip>ล้าง</paper-tooltip>
      </div>

      <div style="display:inline-block">
    <paper-icon-button disabled="[[!iconList.length]]" icon="select-all" on-click="_onSelectAllButtonTap"></paper-icon-button>
    <paper-tooltip>เลือกหมด</paper-tooltip>
      </div>

      <div style="display:inline-block">
    <paper-icon-button disabled="[[!selectedImages.length]]" icon="delete" on-click="_onDeleteButtonTap"></paper-icon-button>
    <paper-tooltip>ลบรูป</paper-tooltip>
      </div>

      <div style="display:inline-block">
    <paper-icon-button disabled="[[!selectedImages.length]]" icon="editor:mode-edit" on-click="_onEditButtonTap"></paper-icon-button>
    <paper-tooltip>แก้ไข</paper-tooltip>
      </div>

      <div style="display:inline-block">
    <paper-icon-button disabled="[[!selectedImages.length]]" icon="reorder" on-click="_onReorderButtonTap"></paper-icon-button>
    <paper-tooltip>เรียง</paper-tooltip>
      </div>

      <div style="display:inline-block">
    <paper-icon-button disabled="[[!selectedImages.length]]" icon="cancel" on-click="_onCancelButtonTap"></paper-icon-button>
    <paper-tooltip>ยกเลือกที่เลือก</paper-tooltip>
      </div>

    </div>
    <input type="file" id="fileInput" on-change="_filesSelected" hidden multiple>
  </div>

  <iron-selector
    id="image-selector"
    attr-for-selected="key"
    selected-values="{{selectedImages}}"
    multi>
  <template is="dom-repeat" items="{{iconList}}" observe="order deleted" sort="{{_reorderPhoto}}">

    <mg-item-image
      key="[[item.key]]"
      class="image-icon"
      thumbnail="[[item.thumbnail]]"
      icon='image:photo'
      rep="[[item.rep]]"
      progress="[[item._progress]]"
      label="[[item.name]]"
      selection-order="[[item._selectionOrder]]"
      deleted="[[item.deleted]]"
      on-tap="_onItemTap"
    >
    <!--
      <template is="dom-if" if="{{_isEditable(item._progress,item.rep)}}">
        <paper-icon-button icon="mode-edit" class="image-edit-button-icon" on-tap="_onEditImage">
        </paper-icon-button>
      </template>
    -->
    </mg-item-image>

  </template>
  </iron-selector>

  <mg-image-editor
    id="image-editor"
    data="{{editingData}}"
    after="[[afterEditingData]]"
    before="[[beforeEditingData]]"
  ></mg-image-editor>

</template>
<script>
(function() {
  let memoizedTemplate;

  class MGGalleryEditor extends MGItemEditor {
    static get is() { return 'mg-gallery-editor'; }

    static get template() {
      if (!memoizedTemplate) {
        memoizedTemplate = Polymer.DomModule.import(this.is, 'template');
        let superTemplateContents = document.importNode(MGItemEditor.template.content, true);
        let editor = memoizedTemplate.content.querySelector('#gallery-editor');
        let firstChild = editor.firstChild;
        editor.insertBefore(superTemplateContents, firstChild);
      }
      return memoizedTemplate;
    }

    static get properties() { return {
      itemRole: {
        type: String,
        value: "gallery",
        readOnly: true,
      },

      files: Object,

      /* iconList collects item data to be displayed, copied and pasted.
         Each array-item may contains..

        [key] : Data ID.

        <role> : The role of this entry, can only be 'photo' in iconList but
          could be any kind of data in clipboard, eg. gallery, product, etc.

        [item] : The key of owner of this data.

        [name] : Display name of the data.

        <thumbnail> : The thumbnail image representing data, a thumbnail of a
          photo or a cover image of a gallery.

        [rep] : Optionally representing source of the thumbnail.
        [roi] : Defiing the region of interest of rep.
        [roiThumbnail] : Defining the part of rep that will be used as thumbnail.
          This property only exist locally so it isn't neccessary to generate
          the actual thumbnail data before the needs of syncing over the server.

        [order] : In gallery, this will be used to sort photos. It doesn't get
          copied along with other properties.

        [deleted] : A deleted state of the data. By design user data will never
          be deleted. Just turn into an obsolete state.

        TODO
        - Type this object somewhere.
      */
      iconList: {
        type: Array,
        value: function(){return [];},
      },

      selectedImages: {
        type: Array,
        value: function(){return [];},
      },

      empty: {
        type: Boolean,
        notify: true,
        reflectToAttribute: true,
      },

      editingData: {
        type: Object,
        observer: '_editingDataChanged',
      },
      afterEditingData: Object,
      beforeEditingData: Object,

      copyMethod: {
        type: String,
        computed: '_computeCopyMethod(selectedImages.length)'
      },

      copyIcon: {
        type: String,
        computed: '_computeCopyIcon(selectedImages.length)'
      },

      defaultName: {
        type: String,
        value: 'แกลเลอรี่ใหม่',
        readOnly: true,
      },

      dropenter: {
        type: Boolean,
        reflectToAttribute: true,
      },
    }}

    connectedCallback() {
      super.connectedCallback();
      this.addEventListener('dragover', e => {
        if (!this.itemKey) {
          return;
        }
        e.preventDefault();
        this.set('dropenter',true);
      });
      this.addEventListener('dragleave', e => {
        if (!this.itemKey) {
          return;
        }
        e.preventDefault();
        this.set('dropenter',false);
      });
      this.addEventListener('drop', e => {
        if (!this.itemKey) {
          return;
        }
        e.preventDefault();
        this.set('dropenter',false);
        this._uploadFiles(e.dataTransfer.files);
      });
    }

    _computeCopyIcon(selectedLen) {
      return selectedLen ? "booed:content-copy-selection" : "content-copy";
    }

    _computeCopyMethod(selectedLen) {
      return selectedLen ? 'ก๊อปปี้ที่เลือก' : 'ก๊อปปี้แกลเลอรี่';
    }

    static get observers() { return [
      '_selectedImagesChanged(selectedImages.splices)',
      '_checkEmpty(iconList.length)',
    ]}

    _checkEmpty(len) {
      this.set('empty', len?false:true);
    }

    _reorderPhoto(a,b) {
      if (a.deleted) {
        if (b.deleted) {
          if (a.key < b.key) {
            return -1;
          }
        }
        return 1;
      }
      if (b.deleted) {
        return -1;
      }

      if (a.order) {
        if (b.order) {
          return a.order - b.order;
        }
        return -1;
      } else if (b.order) {
        return 1;
      }

      if (a.key < b.key) {
        return -1;
      }

      return 1;
    }

    _isEditable(progress,rep) {
      if (!rep) return false;
      if (progress && progress != 100) return false;
      if (progress === 0) return false;
      return true;
    }

    _selectedImagesChanged(changes) {
      if (changes) {
        /* Remove number from deselected photo */
        changes.indexSplices.forEach(splice => {
          splice.removed.forEach(removedKey => {
            this._setPhotoKeyProperty(removedKey,'_selectionOrder',null);
          })
        });

        let orderNumber = 0;
        this.selectedImages.forEach(key => {
          this._setPhotoKeyProperty(key,'_selectionOrder',++orderNumber);
        });
      }
    }

    _onItemTap(e) {

      if (e.detail.sourceEvent.shiftKey) {
        if (typeof(this._LastTapIndex) == "undefined") {
          this._LastTapIndex = -1;
        }

        let inc = this._LastTapIndex < e.model.index ? 1 : -1;

        for (let i = this._LastTapIndex + inc; inc > 0 ? i < e.model.index : i > e.model.index; i+=inc) {
          this.$['image-selector'].selectIndex(i);
        }
      }
      this._LastTapIndex = e.model.index;
    }

    _indexImage(imageKey,cb,nacb) {
      /* XXX optimize later
      if (!this._ImageMap) {
        this._ImageMap = newMap();
      }

      let idx = this._ImageMap.get(imageKey);
      if (this.iconList.length > idx &&  this.iconList[idx].key == imageKey) {
        return idx;
      }
      */

      let i, data;
      for (i = 0; data = this.iconList[i]; ++i) {
        //this._ImageMap.set(data.key, i);
        if (data.key == imageKey) {
          if (cb) { cb(i,data); }

          return i;
        }
      }

      if (nacb) { nacb(cb);}
      return -1;
    }

    _setPhotoKeyProperty(key,prop,val) {
      let idx = this._indexImage(key);
      if (idx !== -1) {
        if (this.iconList[idx][prop] != val) {
          this.set(['iconList',idx,prop],val);
        }
      }
    }

    _uploadReps(uid,itemKey,files) {
      Array.from(files).forEach(imgFile => {
        let imageKey =  MHA.DB.ref('home').child(uid).child(itemKey).child('images').push().key;
        let imageName = imgFile.name.split('.')[0];
        //let coverImageKey = MHA.get(['items',itemKey,'cover']) || imageKey;
        let coverImageKey = MHA.getItem({[itemKey]:{cover:null}}) || imageKey;
        MHA.setItem(itemKey,{ cover: coverImageKey });

        let registerInfo = {};
        function registerImageReps() {

          /* Update once thumbnail and rep are both uploaded onto storage */
          if (registerInfo.thumbnail && registerInfo.rep) {
            let registerData = {
              ['representations/'+registerInfo.rep+'/uid']: uid,
              ['representations/'+registerInfo.thumbnail+'/uid']: uid,
              ['home/'+uid+'/items/'+itemKey+'/cover']: coverImageKey,
              ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/thumbnail']: registerInfo.thumbnail,
              ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/rep']: registerInfo.rep,
              ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/name']: registerInfo.name,
            }
            MHA.DB.ref().update(registerData, error => {
              if (error) {
                console.error("ERR",error);
              }
            });
          }
        }

        MHA.registerRepresentation(imgFile, {
          progress: (repKey,progress) => {
              this._setPhotoKeyProperty(imageKey, '_progress', (progress.bytesTransferred / progress.totalBytes * 100).toFixed(2));
          },
          complete: (repKey,complete) => {
            MHA.setItem(itemKey,{
              images: {
                [imageKey]: {
                  rep: repKey,
                }
              },
            });

            /* This will contain customizations like ROIs, thumbnail, custom name */
            registerInfo.rep = repKey;
            registerInfo.name = imageName;
            /* Published item, Will also contain tags */
            registerImageReps();
          },
          src: (repKey,src) => {

            /* src here is e.target.result of source image file from FileReader,
             * Will use it to generate thumbnail image data.
             */

            let thumbnailLoader = new Image();
            let canvas = document.createElement('canvas');

            thumbnailLoader.onload = (e) => {
              let area = (250*250); /* Default area size for thumbnail */
              /* Try relying with data sizes rather geometries. */
              let w = Math.ceil(Math.sqrt(area * thumbnailLoader.width / thumbnailLoader.height));
              let h = Math.ceil(area / w);

              canvas.width = w;
              canvas.height = h;
              canvas.getContext('2d').drawImage(thumbnailLoader, 0, 0, w, h);
              canvas.toBlob(blob => {

                /* Thumbnail's actual upload should start after finishing image upload */
                MHA.registerRepresentation(blob, {
                  key: key => {

                    this.push('iconList',{
                      item: itemKey,
                      role: 'photo',
                      key: imageKey,
                      thumbnail: key,
                      name: imageName,
                      rep: repKey,
                      _progress: 0,
                    });

                  },
                  src: (key,src) => {
                    MHA.setItem(itemKey,{
                      images: {
                        [imageKey]: {
                          name: imageName,
                          thumbnail: key,
                        }
                      },
                    });
                  },
                  complete: key => {
                    /* This will contain customizations like ROIs, thumbnail, custom name */
                    registerInfo.thumbnail = key;
                    /* Published item, Will also contain tags */
                    registerImageReps();
                  },
                });

              },'image/jpeg',0.8);
            }; /* end thumbnailLoader.onload */
            thumbnailLoader.src = src;

          }

        });

      }); /*forEach(files)*/
    }

    _filesSelected(e) {
      this._uploadFiles(e.target.files);
    }

    _uploadFiles(files) {
      if (!files || !files.length) {
        return;
      }

      let itemKey = this.itemKey;
      let uid = MHA.AU.currentUser.uid;
      let role = this.itemRole;
      let name = this.itemName;

      console.assert(role, "Role is missing");

      MHA.setItem(itemKey,{
          _uid: uid,
          name: name,
          role: role,
          time: firebase.database.ServerValue.TIMESTAMP,
      });

      var registerData = {
        ['home/'+uid+'/items/'+itemKey+'/role']: role,
        ['home/'+uid+'/items/'+itemKey+'/name']: name,
        ['items/'+itemKey+'/uid']: uid,
        ['items/'+itemKey+'/role']: role,
        ['items/'+itemKey+'/name']: name,
        ['items/'+itemKey+'/public']: false,
      };

      MHA.DB.ref().update(registerData, error => { if (!error) {} });

      this._uploadReps(uid,itemKey,files);
    }

    _getDataError(error) {
      console.error("ERR", error);
      this._ItemReference.off('value', this._onItemSnapshot, this);
      delete this._ItemReference;
    }

    /* TODO
     * - Unify data updating function, this and updateChanges.
     *   Could start by turning mg-data into a wrapper arond
     *   a global class data.
     */
    _itemKeyChanged(itemKey) {

      delete this._LastTapIndex;

      this.iconList.forEach((icon,index) => {
        this.set(['iconList',index,'thumbnail'],null);
      });

      this.splice('iconList',0,this.iconList.length);

      this.splice('selectedImages',0,this.selectedImages.length);

      super._itemKeyChanged(itemKey);

      if (!itemKey) return;

      let item = MHA.getItem({[itemKey]:null});
      for(let prop in item) {
        switch(prop) {
          case '_uid':
            break;
          case 'cover':
            this.set('itemCover',item.cover);
            break;
          case 'name':
            this.set('itemName', item.name);
            break;
          case 'role':
            console.assert('gallery' == item.role, "XXX");
            break;
          case 'images': {
            let allImages = item.images;
            for (let imageKey in allImages) {
              let image = allImages[imageKey];
              let icon = {
                item: itemKey,
                role: 'photo',
                key: imageKey,
                thumbnail: image.thumbnail,
                rep: image.rep,
                name: image.name,
                order: image.order,
                deleted: image.deleted,
                roi: image.roi,
              };
              this.push('iconList', icon);
            }
          } break;
          default:
        }
      }
    }

    /* Set image thumbnails from global notification */
    updateChanges(path,value) {
      switch(path[0]) {
        case 'cover': {
          this.set('itemCover',value);
        } break;
        case 'name': {
          this.set('itemName', value);
        } break;
        case 'images': {
          let imageKey = path[1];

          switch(path.length) {
            case 2: {
              this._indexImage(imageKey,null,cb => {
                this.push('iconList', {item:this.itemKey, key:imageKey, role:'photo'});
              });
            } break;
            case 3: {
              let imageProperty = path[2];
              this._indexImage(imageKey,idx => {
                this.set(['iconList',idx,imageProperty], value);
              });
            } break;
            default:
              break;
          }

        } break;
      }
    }


    _formatSize(bytes) {
      const base = 1024;
      const unit = ~~(Math.log(bytes) / Math.log(base));
      const dec = Math.max(0, Math.min(3, unit - 1));
      const size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
      return size + ' ' + ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'][unit];
    }

    _onDrop(e) {
      console.log(e);
    }

    _onAddButtonTap(e) {
      this.$.fileInput.value = '';
      this.$.fileInput.click();
    }

    _onReorderButtonTap(e) {
      let registerData = {};
      let autoNumber = this.selectedImages.length;

      this.iconList.map((item, idx) => {
        return {index: idx, order:item.order|| Number.MAX_SAFE_INTEGER};
      })
      .sort((a,b) => a.order - b.order)
      .map(item => this.iconList[item.index])
      .forEach(icon => {
          if (icon._selectionOrder == 1) {
            registerData['home/'+MHA.AU.currentUser.uid+'/items/'+this.itemKey+'/cover'] = icon.key;
          }
          registerData['home/'+MHA.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+icon.key+'/order'] = icon._selectionOrder || ++autoNumber;
      });


      MHA.DB.ref().update(registerData, error => {
        console.assert(!error,"ERR updating order");
      });
      this.splice('selectedImages',0,this.selectedImages.length);
    }

    _onDeleteButtonTap(e) {
      let registerData = {};
      let selectedImages = this.selectedImages;

      this.selectedImages.forEach(selectedKey => {
        //let del = MHA.get(['items',this.itemKey,'images',selectedKey,'deleted']) ? null:true;
        let del = MHA.getItem({[itemKey]:{images:{[selectedKey]:{deleted:null}}}}) ? null:true;
        MHA.setItem(this.itemKey, {images:{[selectedKey]:{deleted:del}}});
        registerData['home/'+MHA.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+selectedKey+'/deleted'] = del;
      });
      this.splice('selectedImages',0,this.selectedImages.length);

      MHA.DB.ref().update(registerData, error => {
          console.assert(!error,"ERR updating deletion");
      });
    }

    _onSelectAllButtonTap(e) {
      for (let i = 0; i < this.iconList.length; i++) {
        this.$['image-selector'].selectIndex(i);
      }
    }

    _onCancelButtonTap(e) {
        this.splice('selectedImages',0,this.selectedImages.length);
    }

    _editingDataChanged(data,oldData) {

      this.unlinkPaths('editingData');
      let idx = this.iconList.indexOf(data);
      if (idx != -1) {
        /* Receiving server update */
        this.linkPaths('editingData',['iconList',idx]);
      }

      this._EditingSelection = this._EditingSelection || [];
      this.set('beforeEditingData',null);
      this.set('afterEditingData',null);
      if (data) {
        let slen = this._EditingSelection.length;
        if (slen) {

          let currentIdx = this._EditingSelection.indexOf(data.key);

          if (currentIdx != -1) {
            this.set('beforeEditingData',this.iconList[this._indexImage(this._EditingSelection[(currentIdx-1+slen) % slen])]);
            this.set('afterEditingData',this.iconList[this._indexImage(this._EditingSelection[(currentIdx+1) % slen])]);
          }
        }
      } else {
        this._EditingSelection.splice(0,this._EditingSelection.length);
      }
    }


    _onEditButtonTap(e) {
      this._EditingSelection = [].concat(this.selectedImages);
      this._indexImage(this._EditingSelection[0], idx => {
        this.set('editingData',this.iconList[idx]);
      });
      this.splice('selectedImages',0,this.selectedImages.length);
    }

    _onCopyButtonTap(e) {
      if (this.selectedImages.length == 0) {
        /* Copy as gallery  */

        let copy = {
          item: this.itemKey,
          role: this.itemRole,
          name: this.itemName,
          //thumbnail: MHA.get(['items',this.itemKey,'images',this.itemCover,'thumbnail']),
          thumbnail: MHA.getItem({[this.itemKey]:{images:{[this.itemCover]:{thumbnail:null}}}}),
        }

        this.push('clipboardList',copy);

        return;
      }

      /* Copy as image(s) */
      this.selectedImages.forEach(imageKey => {
        this._indexImage(imageKey, idx => {
          let copy = {
            role: 'photo',
            name: this.iconList[idx].name,
            thumbnail: this.iconList[idx].thumbnail,
            rep: this.iconList[idx].rep,
            roi: this.iconList[idx].roi,
          };
          this.push('clipboardList',copy);
        });
      });

      this.splice('selectedImages',0,this.selectedImages.length);
    }

    _onClearButtonTap(e) {
      this.splice('clipboardList', 0, this.clipboardList.length);
    }

    _onPasteButtonTap(e) {
      let paste = this.clipboardList.filter(item => { return item.deleted ? false : true; });
      console.assert(paste.length, "Empty pasted data");

      let uid = MHA.AU.currentUser.uid;
      let itemKey = this.itemKey;
      let path = 'home/'+uid+'/items/'+itemKey;
      let ref = MHA.DB.ref('home').child(uid).child(itemKey).child('images');
      let registerData = {
        ['items/'+itemKey+'/public']: false,
        ['items/'+itemKey+'/uid']: uid,
        ['items/'+itemKey+'/role']: this.itemRole,
        ['items/'+itemKey+'/name']: this.itemName,
        [path+'/role']: this.itemRole,
        [path+'/name']: this.itemName,
      };

      path+='/images/';
      //let coverKey = MHA.get(['items',itemKey,'cover']);
      let coverKey = MHA.getItem({[itemKey]:{cover:null}});
      let area = (250*250); /* Pixel area for creating thumbnail */
      let waitThumbnails = 0; /* waiting counter for all completions */

      paste.forEach((data,index) => {
        if (data.deleted || data.role != 'photo') return;
        /* XXX Will pull data off item.gallery */


        let imageKey = ref.push().key;
        coverKey = coverKey || imageKey;
        registerData[path+imageKey+'/name'] = data.name || null;
        registerData[path+imageKey+'/rep'] = data.rep || null;

        /* If thumbnails were virtually defined with ROIs, it bakes them first */
        if (data.roiThumbnail) {
          waitThumbnails++;
          MHA.registerRepresentation(data.rep,{src: (key,src) => {

            let imageLoader = new Image();
            imageLoader.crossOrigin="anonymous";
            imageLoader.onload = e => {
              let width = imageLoader.naturalWidth;
              let height = imageLoader.naturalHeight;

              let tl = width * data.roiThumbnail[0];
              let tt = height * data.roiThumbnail[1];
              let tw = width * data.roiThumbnail[2];
              let th = height * data.roiThumbnail[3];

              let w = Math.ceil(Math.sqrt(area * tw/th));
              let h = Math.ceil(area / w);

              let canvas = document.createElement('canvas');
              canvas.width = w;
              canvas.height = h;

              canvas.getContext('2d').drawImage(imageLoader, tl, tt, tw, th, 0, 0, w, h);
              canvas.toBlob( thumbnailBlob => {
                MHA.registerRepresentation( thumbnailBlob, {
                  key: thumbnailKey => {
                    /* Rather waits until upload complete, announces the
                     * instances immediately to catch up with user actions.
                     * Doing this will show empty loading thumbnails.
                     * Since it will use a returned locally stored dataURI generated
                     * from Blob it doesn't need the uploading process to complete.
                     */
                    MHA.setItem(itemKey, {
                      images: {[imageKey]: {thumbnail: thumbnailKey, roiThumbnail: null}},
                    });
                  },
                  complete: (thumbnailKey,complete) => {
                    registerData[path+imageKey+'/thumbnail'] = thumbnailKey;

                    waitThumbnails--;
                    if (waitThumbnails == 0) {
                      MHA.DB.ref().update(registerData, error => {
                        if (!error) {
                        } else {
                          console.error("ERR",error);
                        }
                      });
                    }
                  },
                });
              }, 'image/jpeg',0.8);
            };
            imageLoader.src = src;

          }});
          let canvas = document.createElement('canvas');



        } else {
          registerData[path+imageKey+'/thumbnail'] = data.thumbnail || null;
        }
      });

      registerData['home/'+uid+'/items/'+itemKey+'/cover'] = coverKey;

      /* XXX Should it also update local? Or should it rely only on query events? */
      /* XXX Need to try off-line. */

      if (waitThumbnails == 0) {
        MHA.DB.ref().update(registerData, error => {
          if (!error) {
          } else {
            console.error("ERR",error);
          }
        });
      }
    }

    _onEditImage(e) {
      let data = e.model.item;
      this.set('editingData',data);
      e.stopImmediatePropagation();
    }

  }

  customElements.define(MGGalleryEditor.is, MGGalleryEditor);
})();
</script>
</dom-module>
