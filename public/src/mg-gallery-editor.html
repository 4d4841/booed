<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="mg-clipboard.html">
<link rel="import" href="mg-item-editor.html">
<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-input.html">
<link rel="import" href="mg-item-image.html">
<link rel="import" href="mg-image-editor.html">

    <dom-module id="mg-gallery-editor">
  <template strip-whitespace>
<style include="mg-item-editor mg-common-styles iron-flex iron-flex-alignment">

#image-selector {
  @apply --layout-horizontal;
  @apply --layout-wrap;
  @apply --layout-flex;
  @apply --layout-start-aligned;
  padding: 0 0 24px 0;
  overflow-y: auto;
  border: 1px solid transparent;
  border-radius: 5px;
  margin: 0 20px 50px 0;
}

:host([dropenter]) #image-selector {
  border: 1px dashed tomato;
}

:host([idle]) #image-selector {
  border: 1px dashed var(--disabled-text-color);
}

:host([nokey]) #image-selector {
  display: none;
}

#gallery-container {
}

.image-thumbnail {
  margin: 2px;
  width: 124px;
  height: 124px;
  --mg-image: {
    width: 120px;
    height: 120px;
  }
}

@media (max-width: 767px) {
  #image-selector {
    padding: 0;
  }

  #gallery-container {
    padding-bottom: 15px;
  }

}
</style>

<mg-clipboard clipboard-list="{{clipboardList}}"></mg-clipboard>

<div id="gallery-container" ondrop="_onDrop" class="vertical layout">

  <div id="control-panel" class="horizontal layout wrap end" hidden$="[[nokey]]">
    <div style="display:inline-block">
  <paper-icon-button icon="booed:add-photo" on-click="_onAddButtonClick"></paper-icon-button>
  <paper-tooltip>เพิ่มรูป</paper-tooltip>
    </div>

    <div style="display:inline-block">
  <paper-icon-button icon="[[copyIcon]]" on-click="_onCopyButtonClick"></paper-icon-button>
  <paper-tooltip>[[copyMethod]]</paper-tooltip>
    </div>

    <div style="display:inline-block">
  <paper-icon-button disabled="[[!clipboardList.length]]" icon="content-paste" on-click="_onPasteButtonClick"></paper-icon-button>
  <paper-tooltip>แปะ</paper-tooltip>
    </div>

    <div style="display:inline-block">
  <paper-icon-button disabled="[[!clipboardList.length]]" icon="booed:content-clear" on-click="_onClearButtonClick"></paper-icon-button>
  <paper-tooltip>ล้าง</paper-tooltip>
    </div>

    <div style="display:inline-block">
  <paper-icon-button disabled="[[!imageList.length]]" icon="select-all" on-click="_onSelectAllButtonClick"></paper-icon-button>
  <paper-tooltip>เลือกหมด</paper-tooltip>
    </div>

    <div style="display:inline-block">
  <paper-icon-button disabled="[[!selectedImageKeys.length]]" icon="delete" on-click="_onDeleteButtonClick"></paper-icon-button>
  <paper-tooltip>ลบรูป</paper-tooltip>
    </div>

    <div style="display:inline-block">
  <paper-icon-button disabled="[[!selectedImageKeys.length]]" icon="editor:mode-edit" on-click="_onEditButtonClick"></paper-icon-button>
  <paper-tooltip>แก้ไข</paper-tooltip>
    </div>

    <div style="display:inline-block">
  <paper-icon-button disabled="[[!selectedImageKeys.length]]" icon="reorder" on-click="_onReorderButtonClick"></paper-icon-button>
  <paper-tooltip>เรียง</paper-tooltip>
    </div>

    <div style="display:inline-block">
  <paper-icon-button disabled="[[!selectedImageKeys.length]]" icon="cancel" on-click="_onCancelButtonClick"></paper-icon-button>
  <paper-tooltip>ยกเลือกที่เลือก</paper-tooltip>
    </div>

  </div>
  <input type="file" id="fileInput" on-change="_filesSelected" hidden multiple>
</div>

<iron-selector
  id="image-selector"
  attr-for-selected="key"
  selected-values="{{selectedImageKeys}}"
  multi
  hidden$="[[nokey]]"
  > <template is="dom-repeat" items="{{imageList}}" as="image" observe="order$ deleted" sort="_computeImageOrder">

<mg-item-image
  key="[[image.key$]]"
  class="image-thumbnail"
  item="[[image]]"
  selection-order="[[_computeSelectionOrder(image.key$, selectedImageKeys.*)]]"
  on-click="_onItemClick"
></mg-item-image>
[[_cacheListedImage(index,image.key$)]]
    <!--
<mg-item-image
  key="[[image.key]]"
  class="image-icon"
  thumbnail="[[image.thumbnail]]"
  icon='image:photo'
  rep="[[image.rep]]"
  progress="[[image.progress$]]"
  label="[[image.name]]"
  selection-order="[[image.selectionOrder$]]"
  deleted="[[image.deleted]]"
>
-->
<!--
  <template is="dom-if" if="{{_isEditable(image.progress$,image.rep)}}">
    <paper-icon-button icon="mode-edit" class="image-edit-button-icon" on-click="_onEditImage">
    </paper-icon-button>
  </template>
[[_cacheIndexImage(index,image.key)]]
-->

  </template>
</iron-selector>

<mg-image-editor
  item="{{item}}"
  keys="{{editorImageKeys}}"
></mg-image-editor>

  </template>
  <script>
(function() {
let memoizedTemplate;

class MGGalleryEditor extends MGItemEditor {
  static get is() { return 'mg-gallery-editor'; }

  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = Polymer.DomModule.import(this.is, 'template');
      let superTemplateContents = document.importNode(MGItemEditor.template.content, true);
      let editor = memoizedTemplate.content.querySelector('#gallery-container');
      let firstChild = editor.firstChild;
      editor.insertBefore(superTemplateContents, firstChild);
    }
    return memoizedTemplate;
  }

  static get properties() { return {
    editorRole: {
      type: String,
      value: 'gallery',
    },

    /* For uploading images */
    files: Object,

    imageList: {
      type: Array,
      value: function(){return [];},
    },

    selectedImageKeys: {
      type: Array,
      value: function(){return [];},
    },

    idle: {
      type: Boolean,
      notify: true,
      reflectToAttribute: true,
    },

    editingData: {
      type: Object,
      observer: '_editingDataChanged',
    },

    copyMethod: {
      type: String,
      computed: '_computeCopyMethod(selectedImageKeys.length)'
    },

    copyIcon: {
      type: String,
      computed: '_computeCopyIcon(selectedImageKeys.length)'
    },

    dropenter: {
      type: Boolean,
      reflectToAttribute: true,
    },
  }}

  static get observers() { return [
    '_checkIdle(imageList.length)',
    '_linkKeysArraySelection(item.images.*)',
    '_orderChanged(item.order)',
  ]}

  connectedCallback() {
    super.connectedCallback();
    this.addEventListener('dragover', e => {
      if (!this.key) {
        return;
      }
      e.preventDefault();
      this.set('dropenter',true);
    });
    this.addEventListener('dragleave', e => {
      if (!this.key) {
        return;
      }
      e.preventDefault();
      this.set('dropenter',false);
    });
    this.addEventListener('drop', e => {
      if (!this.key) {
        return;
      }
      e.preventDefault();
      this.set('dropenter',false);
      this._uploadImageFiles(e.dataTransfer.files);
    });

  }

  _computeCopyIcon(selectedLen) {
    return selectedLen ? "booed:content-copy-selection" : "content-copy";
  }

  _computeCopyMethod(selectedLen) {
    return selectedLen ? 'ก๊อปปี้ที่เลือก' : 'ก๊อปปี้แกลเลอรี่';
  }

  _computeSelectionOrder(key) {
    return 1 + this.selectedImageKeys.indexOf(key);
  }

  _checkIdle(len) {
    this.set('idle', len?false:true);
  }

  _computeImageOrder(a,b) {
    if (a.deleted) {
      if (b.deleted) {
        if (a.key$ < b.key$) {
          return -1;
        }
      }
      return 1;
    }
    if (b.deleted) {
      return -1;
    }

    if ('order$' in a) {
      if ('order$' in b) {
        return a.order$ - b.order$;
      }
      return -1;
    } else if ('order$' in b) {
      return 1;
    }

    if (a.key$ < b.key$) {
      return -1;
    }

    return 1;
  }

  _isEditable(progress,rep) {
    if (!rep) return false;
    if (progress && progress != 100) return false;
    if (progress === 0) return false;
    return true;
  }

  _onItemClick(e) {
    if (e.shiftKey) {
      if (typeof(this._LastClickIndex) == "undefined") {
        this._LastClickIndex = -1;
      }

      let inc = this._LastClickIndex < e.model.index ? 1 : -1;

      /* Finds if the last click was de/selection. */
      let selecting = true;
      if (this.selectedImageKeys.length && this._LastClickIndex > -1
        && this.selectedImageKeys.indexOf(this.IndexImageCache[this._LastClickIndex])
           == -1) {
        selecting = false;
      }

      for (let i = this._LastClickIndex + inc;
        inc > 0 ? i <= e.model.index : i >= e.model.index; i += inc) {

        let ikey = this.IndexImageCache[i];
        let oldIndex = this.selectedImageKeys.indexOf(ikey);
        if (oldIndex > -1) {
          this.splice('selectedImageKeys',oldIndex,1);
        }
        if (selecting) {
          this.push('selectedImageKeys',ikey);
        }
      }
    }
    if (this.selectedImageKeys.length) {
      this._LastClickIndex = e.model.index;
    } else {
      this._LastClickIndex = -1;
    }
  }

  _indexImage(imageKey,cb,nacb) {
    /* XXX optimize later
    if (!this._ImageMap) {
      this._ImageMap = newMap();
    }

    let idx = this._ImageMap.get(imageKey);
    if (this.imageList.length > idx &&  this.imageList[idx].key == imageKey) {
      return idx;
    }
    */

    let i, data;
    for (i = 0; data = this.imageList[i]; ++i) {
      //this._ImageMap.set(data.key, i);
      if (data.key == imageKey) {
        if (cb) { cb(i,data); }

        return i;
      }
    }

    if (nacb) { nacb(cb);}
    return -1;
  }

  _setPhotoKeyProperty(imageKey,prop,val) {
    let idx = this._indexImage(imageKey);
    if (idx !== -1) {
      if (this.imageList[idx][prop] != val) {
        this.set(['imageList',idx,prop],val);
      }
    }
  }

  _uploadImageFiles(files) {
    if (!files || !files.length) {
      return;
    }
    let uid = MHA.AU.currentUser.uid;
    let itemKey = this.item.key$;

    Array.from(files).forEach((imgFile,fileIndex) => {
      let imageKey =  MHA.DB.ref('items').push().key;
      let imageName = imgFile.name.split('.')[0];

      console.log('will set',['items',itemKey,'images',imageKey]);
      MHA.set(['items',itemKey,'images',imageKey], {
        MGLOCALDATA$: true,
        key$: imageKey,
        name: imageName,
      });

        let repOrThumbnailComplete = false;
        function checkUpdateReady() {
          if (!repOrThumbnailComplete) {
            repOrThumbnailComplete = true;
            return;
          }

          /* Unlock the image's local switch */
          console.log('toggle MGLOCALDATA$ off');
          MHA.set(['items',itemKey,'images',imageKey,'MGLOCALDATA$'], false);
          if (fileIndex == 0) {
            /* If no cover, set the first selected file as a cover */
            MHA.set(['items',itemKey,'cover'], MHA.get(['items',itemKey,'cover']) || imageKey);
          }
        }

      MHA.registerRepresentation(imgFile, {
        key: repKey => {
          MHA.set(['items',itemKey,'images',imageKey,'rep'], repKey);
        },
        progress: (repKey,progress) => {
          //this._setPhotoKeyProperty(imageKey, 'progress$', (progress.bytesTransferred / progress.totalBytes * 100).toFixed(2));
          //console.log((progress.bytesTransferred / progress.totalBytes * 100).toFixed(2));
          MHA.set(['items',itemKey,'images',imageKey,'progress$'], (progress.bytesTransferred / progress.totalBytes * 100).toFixed(2));
        },
        complete: (repKey,complete) => {
          checkUpdateReady();
        },
        src: (repKey,src) => {

          /* src here is e.target.result of source image file from FileReader,
           * Will use it to generate thumbnail image data.
           */

          let thumbnailLoader = new Image();
          let canvas = document.createElement('canvas');

          thumbnailLoader.onload = (e) => {
            let area = (250*250); /* Default area size for thumbnail */
            /* Try relying with data sizes rather geometries. */
            let w = Math.ceil(Math.sqrt(area * thumbnailLoader.width / thumbnailLoader.height));
            let h = Math.ceil(area / w);

            canvas.width = w;
            canvas.height = h;
            canvas.getContext('2d').drawImage(thumbnailLoader, 0, 0, w, h);
            canvas.toBlob(blob => {

              /* Thumbnail's actual upload should start after finishing image upload */
              MHA.registerRepresentation(blob, {
                key: thumbnail => {
                  MHA.set(['items',itemKey,'images',imageKey,'thumbnail'],thumbnail);
                },
                complete: thumbnail => {
                  checkUpdateReady();
                },
              });

            },'image/jpeg',0.8);
          }; /* end thumbnailLoader.onload */
          thumbnailLoader.src = src;

        }

      });

    }); /*forEach(files)*/
  }

  _filesSelected(e) {
    this._uploadImageFiles(e.target.files);
  }

  /* TODO
   * - Unify data updating function, this and updateChanges.
   *   Could start by turning mg-data into a wrapper arond
   *   a global class data.
   */
   /*
  _keyChanged(itemKey) {
    delete this._LastClickIndex;

    this.imageList.forEach((icon,index) => {
      this.set(['imageList',index,'thumbnail'],null);
    });

    this.splice('imageList',0,this.imageList.length);

    this.splice('selectedImageKeys',0,this.selectedImageKeys.length);

    super._keyChanged(itemKey);

    if (!itemKey) return;

    let item = MHA.getItem({[itemKey]:null});
    for(let prop in item) {
      switch(prop) {
        case '_uid':
          break;
        case 'cover':
          this.set('cover',item.cover);
          break;
        case 'name':
          this.set('name', item.name);
          break;
        case 'role':
          this.set('role', item.role);
          break;
        case 'images': {
          let allImages = item.images;
          for (let imageKey in allImages) {
            let image = allImages[imageKey];
            let icon = {
              item: itemKey,
              role: 'photo',
              key: imageKey,
              thumbnail: image.thumbnail,
              rep: image.rep,
              name: image.name,
              order: image.order,
              deleted: image.deleted,
              roi: image.roi,
            };
            this.push('imageList', icon);
          }
        } break;
        default:
      }
    }
  }
  */

  _linkKeysArraySelection(change) {
    switch(change.path.length) {
    case 11: { /* item.images */
      this.splice('selectedImageKeys',0,this.selectedImageKeys.length);
    } break;
    case 32: { /* item.images.< 20 chars new key > */
      if (!change.value) {
        this.splice('selectedImageKeys',this.selectedImageKeys.indexOf(change.path.slice(-20)),1);
      }
    } break;
    default: {
      //console.log('DEBUG', change);
    }}

    super._linkKeysArraySelection(change,"item.images","imageList");
  }

  _orderChanged(order) { if (order) {
    order.forEach((key,index) => {
      this.set('item.images.'+key+'.order$', index);
    });
  }}

  _formatSize(bytes) {
    const base = 1024;
    const unit = ~~(Math.log(bytes) / Math.log(base));
    const dec = Math.max(0, Math.min(3, unit - 1));
    const size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
    return size + ' ' + ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'][unit];
  }

  _onDrop(e) {
    console.log(e);
  }

  _onAddButtonClick(e) {
    this.$.fileInput.value = '';
    this.$.fileInput.click();
  }

  _onReorderButtonClick(e) {
    let autoNumber = this.selectedImageKeys.length;
    let neworder = [...this.selectedImageKeys];

    if (this.item.order) {
      this.item.order.forEach(key => {
        if (neworder.indexOf(key) == -1) {
          neworder.push(key);
        }
      });
    }

    this.imageList.forEach(image => {
      if (neworder.indexOf(image.key$) == -1) {
        neworder.push(image.key$)
      }
    });

    this.set('item.order', neworder);
    this.splice('selectedImageKeys',0,this.selectedImageKeys.length);
  }

  _onDeleteButtonClick(e) {
    let selectedImageKeys = this.selectedImageKeys;

    this.selectedImageKeys.forEach(selectedKey => {
      this.set('item.images.'+selectedKey+'.deleted',!this.item.images[selectedKey].deleted);
    });
    this.splice('selectedImageKeys',0,this.selectedImageKeys.length);
  }

  /* This will update a cache that match the actual listed result of
   * dom-repeat to avoid dealing with sorted/filtered results.
   */
  _cacheListedImage(index,imageKey) {
    let IndexImageCache = (this.IndexImageCache || (this.IndexImageCache = []));
    IndexImageCache[index] = imageKey;
  }

  _onSelectAllButtonClick(e) {
    for (let i = 0; i < this.imageList.length; i++) {
      let imageKey = this.IndexImageCache[i];
      let oldIndex = this.selectedImageKeys.indexOf(imageKey);
      if (oldIndex > -1) {
        this.splice('selectedImageKeys',oldIndex,1);
      } else {
        this.push('selectedImageKeys',imageKey);
      }
    }
  }

  _onCancelButtonClick(e) {
    this.splice('selectedImageKeys',0,this.selectedImageKeys.length);
    this._LastClickIndex = -1;
  }

  /*
  _editingDataChanged(data,oldData) {

    this.unlinkPaths('editingData');
    let idx = this.imageList.indexOf(data);
    if (idx != -1) {
      this.linkPaths('editingData',['imageList',idx]);
    }

    this._EditingSelection = this._EditingSelection || [];
    this.set('beforeEditingData',null);
    this.set('afterEditingData',null);
    if (data) {
      let slen = this._EditingSelection.length;
      if (slen) {

        let currentIdx = this._EditingSelection.indexOf(data.key);

        if (currentIdx != -1) {
          this.set('beforeEditingData',this.imageList[this._indexImage(this._EditingSelection[(currentIdx-1+slen) % slen])]);
          this.set('afterEditingData',this.imageList[this._indexImage(this._EditingSelection[(currentIdx+1) % slen])]);
        }
      }
    } else {
      this._EditingSelection.splice(0,this._EditingSelection.length);
    }
  }
  */

  /*
  _onEditButtonClick(e) {
    this._EditingSelection = [].concat(this.selectedImageKeys);
    this._indexImage(this._EditingSelection[0], idx => {
      this.set('editingData',this.imageList[idx]);
    });
    this.splice('selectedImageKeys',0,this.selectedImageKeys.length);
  }
  */

  _onEditButtonClick(e) {
    this.set('editorImageKeys', [].concat(this.selectedImageKeys));
    this.splice('selectedImageKeys',0,this.selectedImageKeys.length);
  }

  _onCopyButtonClick(e) {
    if (this.selectedImageKeys.length == 0) {
      /* Copy as gallery  */

      let clipboardItem = {
        role: this.item.role,
        name: this.item.name,
        images: {},
      }

      if (this.item.order) {
        clipboardItem.order = [...this.item.order];
      }

      if (clipboardItem.order && clipboardItem.order.length) {
        clipboardItem.cover = clipboardItem.order[0];
      }

      for (let imageKey in this.item.images) {
        let newImageKey = MHA.DB.ref('home').child(MHA.AU.currentUser.uid)
          .child(this.item.key$).child('images').push().key;
        clipboardItem.images[newImageKey] = this.item.images[imageKey];

        if (!clipboardItem.cover || clipboardItem.cover === imageKey) {
          clipboardItem.cover = newImageKey;
        }
      }

      this.push('clipboardList',clipboardItem);

      return;
    }

    /* Copy as image(s) */
    this.selectedImageKeys.forEach(imageKey => {
      let clipboardImage = {
        name: this.item.images[imageKey].name,
        rep: this.item.images[imageKey].rep,
        thumbnail: this.item.images[imageKey].thumbnail,
      };

      this.push('clipboardList', clipboardImage);
    });

    this.splice('selectedImageKeys',0,this.selectedImageKeys.length);
  }

  _onClearButtonClick(e) {
    this.splice('clipboardList', 0, this.clipboardList.length);
  }

  _onPasteButtonClick(e) {
    let paste = this.clipboardList.filter(item => { return item.deleted ? false : true; });
    console.assert(paste.length, "Empty pasted data");

    let uid = MHA.AU.currentUser.uid;
    let itemKey = this.key;
    let path = 'home/'+uid+'/items/'+itemKey;
    let ref = MHA.DB.ref('home').child(uid).child(itemKey).child('images');
    let registerData = {
      ['items/'+itemKey+'/public']: false,
      ['items/'+itemKey+'/uid']: uid,
      ['items/'+itemKey+'/role']: this.role,
      ['items/'+itemKey+'/name']: this.name,
      [path+'/role']: this.role,
      [path+'/name']: this.name,
    };

    path+='/images/';
    let cover = MHA.getItem({[itemKey]:{cover:null}});
    let area = (250*250); /* Pixel area for creating thumbnail */
    let waitThumbnails = 0; /* waiting counter for all completions */

    paste.forEach((data,index) => {
      if (data.deleted || data.role != 'photo') return;
      /* XXX Will pull data off item.gallery */


      let imageKey = ref.push().key;
      cover = cover || imageKey;
      registerData[path+imageKey+'/name'] = data.name || null;
      registerData[path+imageKey+'/rep'] = data.rep || null;

      /* If thumbnails were virtually defined with ROIs, it bakes them first */
      if (data.roiThumbnail) {
        waitThumbnails++;
        MHA.registerRepresentation(data.rep,{src: (repKey,src) => {

          let imageLoader = new Image();
          imageLoader.crossOrigin="anonymous";
          imageLoader.onload = e => {
            let width = imageLoader.naturalWidth;
            let height = imageLoader.naturalHeight;

            let tl = width * data.roiThumbnail[0];
            let tt = height * data.roiThumbnail[1];
            let tw = width * data.roiThumbnail[2];
            let th = height * data.roiThumbnail[3];

            let w = Math.ceil(Math.sqrt(area * tw/th));
            let h = Math.ceil(area / w);

            let canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;

            canvas.getContext('2d').drawImage(imageLoader, tl, tt, tw, th, 0, 0, w, h);
            canvas.toBlob( thumbnailBlob => {
              MHA.registerRepresentation( thumbnailBlob, {
                key: thumbnail => {
                  /* Rather waits until upload complete, announces the
                   * instances immediately to catch up with user actions.
                   * Doing this will show empty loading thumbnails.
                   * Since it will use a returned locally stored dataURI generated
                   * from Blob it doesn't need the uploading process to complete.
                   */
                  MHA.setItem(itemKey, {
                    images: {[imageKey]: {thumbnail: thumbnail, roiThumbnail: null}},
                  });
                },
                complete: (thumbnail,complete) => {
                  registerData[path+imageKey+'/thumbnail'] = thumbnail;

                  waitThumbnails--;
                  if (waitThumbnails == 0) {
                    MHA.DB.ref().update(registerData, error => {
                      if (!error) {
                      } else {
                        console.error("ERR",error);
                      }
                    });
                  }
                },
              });
            }, 'image/jpeg',0.8);
          };
          imageLoader.src = src;

        }});
        let canvas = document.createElement('canvas');



      } else {
        registerData[path+imageKey+'/thumbnail'] = data.thumbnail || null;
      }
    });

    registerData['home/'+uid+'/items/'+itemKey+'/cover'] = cover;

    /* XXX Should it also update local? Or should it rely only on query events? */
    /* XXX Need to try off-line. */

    if (waitThumbnails == 0) {
      MHA.DB.ref().update(registerData, error => {
        if (!error) {
        } else {
          console.error("ERR",error);
        }
      });
    }
  }

  _onEditImage(e) {
    let data = e.model.item;
    this.set('editingData',data);
    e.stopImmediatePropagation();
  }

}

customElements.define(MGGalleryEditor.is, MGGalleryEditor);
})();
  </script>
    </dom-module>
