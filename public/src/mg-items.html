<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../bower_components/app-route/app-route.html">
<link rel="import" href="mg-icons.html">
<link rel="import" href="mg-balloon.html">
<link rel="import" href="mg-menu.html">
<link rel="import" href="mg-item.html">
<link rel="import" href="mg-item-image.html">


<dom-module id="mg-items">
  <template strip-whitespace>
    <style>
      :host {
        @apply --layout-horizontal;
      }

      #new-item {
        margin-left: 25px;
        width: 100px;
        padding:0;
        height:40px;
        box-shadow: 1px 1px 2px var(--app-shadow-color);
        --paper-button: {
          font-family: 'Mitr', sans-serif;
          font-size: 16px;
          background-color: tomato;
          color: white;
        }
      }

      #new-item-balloon {
        display: none;
        z-index: 10;
        margin: 0;
      }

      .items-container {
        @apply(--layout-vertical);
        padding: 20px;
        height: 100%;
      }

      .item {
        width: 100px;
        height: 130px;
        margin-bottom: 5px;
      }

      #editor {
        margin: 0 20px 20px 20px;
        width: 100%;
        height: 100%;
      }

      a {
        text-decoration: none;
      }

    </style>

    <div class="vertical layout" style="min-width:150px;height:100vh; border-right:1px dashed tomato">

      <paper-button id="new-item" on-tap="_openNewItemMenu">
        <iron-icon icon="add"></iron-icon> สร้าง
      </paper-button>

      <iron-selector class="items-container" attr-for-selected="name" selected="[[itemKey]]">
      <template is="dom-repeat" items="[[itemList]]" mutable-data>
        <mg-item-image
          name="[[item.key]]"
          label="[[item.name]]"
          icon="[[_formatRoleIcon(item.role)]]"
          src="[[item._src]]"
          class="item"
          on-click="_onThumbClick"
        ></mg-item-image>
      </template>
      </iron-selector>

    </div>


    <mg-balloon id="new-item-balloon" no-overlap vertical-align="top" dynamic-align horizontal-align="auto">
      <mg-menu selected-item="{{newItemSelected}}" menu="[[newMenu]]"></mg-menu>
    </mg-balloon>

    <mg-item
      id="editor"
      me="[[me]]"
      item-key="{{itemKey}}"
      items={{items}}
      app-images="{{appImages}}"
    ></mg-item>

    <app-route
        route="{{route}}"
        pattern="/:itemKey"
        data="{{routeData}}"
        tail="{{subroute}}">
    </app-route>

  </template>
  <script>
    class MGItems extends Polymer.Element {
      static get is() { return 'mg-items'; }
      static get properties() { return {
        selectedItem: Number,
        itemList: {
          type: Array,
          value: [],
        },
        menu: {
          type: Object,
          value: { entries: [
            {name:"products", icon:"local-mall", title:"สินค้า" },
            {name:"articles", icon:"local-library", title:"อาร์ติเคิล" },
            {name:"collections", icon:"group-work", title:"คอลเลคชั่น" },
            {name:"galleries", icon:"photo-library", title:"แกลเลอรี่" },
          ]}
        },
        newMenu: {
          type: Object,
          value: {
            entries: [
              {name:"product", icon:"local-mall", title:"สินค้า" },
              {name:"article", icon:"local-library", title:"อาร์ติเคิล" },
              {name:"collection", icon:"group-work", title:"คอลเลคชั่น" },
              {name:"gallery", icon:"photo-library", title:"แกลเลอรี่" },
            ],
          }
        },
        visible: {
          type: Boolean,
          value: false,
        },
      }}

      static get observers() { return [
        '_itemKeyChanged(itemKey)',
        '_routeDataChanged(routeData)',
        '_userChanged(me.user.uid)',
        '_visibleChanged(visible)',
//        '_onNewItemSelected(newItemSelected)',
      ]}

      connectedCallback() {
        super.connectedCallback();
        window.addEventListener('close-contextual-menu', this._closeSubmenu.bind(this));
        this.menu.action = this._onSelectedItemType.bind(this);
        this.newMenu.action = this._onNewItemTap.bind(this);
      }

      _visibleChanged(visible) {
        if (!visible) {
          this.set('itemKey',null);
        }
      }

      _formatRoleIcon(role) {
        return MGIconForRole(role);
      }

      _userChanged(uid) {
        this.set('itemList',[]);
        if (this._UidChangedCallback) {
          MGAPP.DB.ref('home')
                  .child(uid)
                  .child('items')
                  .off('child_added', this._UidChangedCallback, this);
          delete this._UidChangedCallback;
        }
        if (uid) {
          this._UidChangedCallback =
          MGAPP.DB.ref('home')
                  .child(uid)
                  .child('items')
                  .on('child_added', function(snapshot){

            let val = snapshot.val();
            let storageRef = MGAPP.ST.ref('home').child(uid).child('representations');

            if( this.itemList.every(function(item){
              /* Check if item exists */
              return item.key != snapshot.key;
            })) {
              /* New item found in snapshot, insert into item list.
               * In expected case it may already add placeholders for keeping
               * items that are being constructed.
               */
              this.unshift('itemList',{
                key: snapshot.key,
                role:val.role,
                name:val.name,
              }) - 1;
            }

            if (val.images) {
              for (let key in val.images) {
                if (val.images[key].order && val.images[key].order != 1) {
                  continue;
                }
                let ref = val.images[key].rep ? storageRef.child(val.images[key].rep):null;
                MGAPP.registerRepresentation(ref, (key,ev,val) => {
                    if (ev == 'src') {
                      this._setPhotoKeyProperty(snapshot.key, '_src', val);
                    }
                  }
                );
                break;
              }
            } else {
              this._setPhotoKeyProperty(snapshot.key, '_src', 'images/logo-pumpkin-outline-grayout.svg');
            }

            let ref = MGAPP.DB.ref('home')
                              .child(uid)
                              .child('items')
                              .child(snapshot.key);

            /* Listen to name changes */
            ref.child('name').on('value', nameSnapshot => {
              this._setPhotoKeyProperty(snapshot.key, 'name', nameSnapshot.val());
            });

            ref.child('images').on('value', imagesSnapshot => {
              let val = imagesSnapshot.val();
              if (!val) { return; } /* no image was registered yet */

              let images = Object.values(val)
              .sort(function(a,b){
                let ao = a.order || Number.MAX_SAFE_INTEGER;
                let bo = b.order || Number.MAX_SAFE_INTEGER;
                return ao-bo;
              });

              if (images.length && images[0].rep) {
                MGAPP.registerRepresentation(storageRef.child(images[0].rep), (key,ev,val) => {
                  if (ev == 'src') {
                    this._setPhotoKeyProperty(snapshot.key,'_src',val);
                  }
                });
              }

            });

            /* Only allow updating item thumbnail/cover once uploading first image*/
            /*
            ref.child('images').orderByChild('order').once('child_added', function(imageSnapshot){
              MGAPP.registerRepresentation(imageSnapshot.val().rep, function(key,ev,val){
                if (ev == 'src') {
                  this._setPhotoKeyProperty(snapshot.key,'_src',val);
                }
              }.bind(this));
            }.bind(this));
            */

          },function(error){},this);
        }
      }

      _indexImage(imageKey) {
        for (let i = 0, data; data = this.itemList[i]; ++i) {
          if (data.key == imageKey) {
            return i;
          }
        }
        return -1;
      }

      _setPhotoKeyProperty(key,prop,val) {
        let idx = this._indexImage(key);
        if (idx > -1) {
          this.itemList[idx][prop] = val;
          this.notifyPath(['itemList',idx,prop]);
        }
      }

      _onThumbClick(e) {
        this.dispatchEvent(new CustomEvent('close-contextual-menu', {
          bubbles: true, composed: true, detail:{sender:this}}));
        this.set('route.path',"/"+e.model.item.key);
      }

      _onSelectedItemType(e) {
        console.log("should display only", e.model.item.name);
      }

      _onNewItemTap(e) {
        this._closeSubmenu(e);
        if (e.model.item.name == 'gallery') {
          this.$.editor.newItem('gallery','แกลเลอรี่ไม่มีชื่อ'); //XXX add date:time
        }
      }

      _itemKeyChanged(newItemId) {
        this.set('route.path', newItemId ? "/"+newItemId : "");
      }

      _routeDataChanged(routeData) {
        if (routeData.itemKey) {
          this.set('itemKey', routeData.itemKey);
        }
      }

      /*
      _onNewItemSelected(newItemSelected) {
      }
      */

      disconnectedCallback() {
        delete this.newMenu.target;
        super.disconnectedCallback();
      }

      _closeSubmenu(e) {
        if (e.detail && e.detail.sender != this) {
          this.$['new-item-balloon'].style.display = "none";
        }
      }

      _willRefit() {
        this.$['new-item-balloon'].style.display = "block";
        this.$['new-item-balloon'].refit();
      }

      /* XXX addd contextual behavior */
      _openNewItemMenu(e) {
        this.dispatchEvent(new CustomEvent('close-contextual-menu', {
          bubbles: true, composed: true, detail:{sender:this}}));

        if (this.$['new-item-balloon'].style.display == "block") {
          this.$['new-item-balloon'].style.display = "none";
          return;
        }

        this.$['new-item-balloon'].positionTarget = this.$['new-item'];
        this.__WillRefitSubmenuDebouncer = Polymer.Debouncer.debounce(this.__WillRefitSubmenuDebouncer,
          Polymer.Async.timeOut.after(10),
          this._willRefit.bind(this));

      }

      addPhoto(photo) {

      }
    }
    customElements.define(MGItems.is, MGItems);
  </script>
</dom-module>
