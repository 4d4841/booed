<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../bower_components/app-route/app-route.html">
<link rel="import" href="mg-icons.html">
<link rel="import" href="mg-balloon.html">
<link rel="import" href="mg-menu.html">
<link rel="import" href="mg-gallery-editor.html">
<link rel="import" href="mg-thumbnail.html">
<link rel="import" href="mg-clipboard.html">

<dom-module id="mg-items">
<template strip-whitespace>
    <custom-style>
  <style>
    :host {
      @apply --layout-horizontal;
    }

    #new-item {
      margin-left: 25px;
      width: 100px;
      padding:0;
      height:40px;
      box-shadow: 1px 1px 2px var(--app-shadow-color);
      --paper-button: {
        font-family: 'Mitr', sans-serif;
        font-size: 16px;
        background-color: tomato;
        color: white;
      }
    }

    #new-item-balloon {
      display: none;
      z-index: 10;
      margin: 0;
    }

    .side-bar {
      @apply --layout-vertical;
      min-width: 300px;
      height: calc(100vh - 100px);
      border-right:1px dashed tomato;
    }

    .items-container {
      @apply --layout-vertical;
      padding: 20px;
      height: calc(100vh - 215px);
      margin-top: 10px;
      overflow-y: scroll;
    }

    .item {
      width: 250px;
      height: 200px;
      margin-bottom: 5px;
    }

    .editor-container {
      margin-left: 20px;
      width: 100%;
      @apply --layout-vertical;
      height: calc(100vh - 100px);
    }

    mg-clipboard {
      margin-right: 20px;
    }

    #editor {
      margin: 0 20px 20px 20px;
      width: 100%;
      @apply --layout-flex;
    }

    a {
      text-decoration: none;
    }

    @media (max-width: 767px) {
      mg-thumbnail > div {
        display: none;
      }

      .item {
        width: 100px;
        height: 100px;
      }

      .side-bar {
        min-width: 150px;
      }

      .items-container {
        height: calc(100vh - 140px);
      }

      .side-bar {
        height: calc(100vh - 70px);
      }

      .editor-container {
        height: calc(100vh - 70px);
      }

    }

    mg-thumbnail iron-icon {
      margin-left: 10px;
    }

  </style>
    </custom-style>

  <div class="side-bar">
    <paper-button id="new-item" on-tap="_openNewItemMenu">
      <iron-icon icon="add"></iron-icon> สร้าง
    </paper-button>

    <iron-selector class="items-container" attr-for-selected="key" selected="[[selectedItemKey]]">
    <template is="dom-repeat" items="[[itemList]]" mutable-data>
      <mg-thumbnail
        key="[[item.key]]"
        label="[[_formatLabel(item.name)]]"
        icon="[[_formatRoleIcon(item.role)]]"
        src="[[item._src]]"
        class="item"
        on-click="_onThumbnailClick"
      >
        <div slot="label">
          <iron-icon icon="photo"></iron-icon>×[[_formatImagesCount(item.images)]]
        </div>
      </mg-thumbnail>
    </template>
    </iron-selector>

  </div>


  <mg-balloon id="new-item-balloon" no-overlap vertical-align="top" dynamic-align horizontal-align="auto">
    <mg-menu menu="[[newItemMenu]]"></mg-menu>
  </mg-balloon>

  <div class="editor-container">
    <mg-clipboard
      class="flex"
      clipboard-list="{{clipboardList}}"
    ></mg-clipboard>

    <mg-gallery-editor
      id="gallery-editor"
      class="flex"
      me="[[me]]"
      clipboard-list="{{clipboardList}}"
    ></mg-gallery-editor>
  </div>

  <app-route
      route="{{route}}"
      pattern="/:selectedItemKey"
      data="{{routeData}}"
      tail="{{subroute}}">
  </app-route>

</template>
<script>
  class MGItems extends Polymer.Element {
    static get is() { return 'mg-items'; }
    static get properties() { return {
      me: Object,

      selectedItem: Number,
      itemList: {
        type: Array,
        value: [],
      },
      menu: {
        type: Object,
        value: { entries: [
          {name:"products", icon:"local-mall", title:"สินค้า" },
          {name:"articles", icon:"local-library", title:"อาร์ติเคิล" },
          {name:"collections", icon:"group-work", title:"คอลเลคชั่น" },
          {name:"galleries", icon:"photo-library", title:"แกลเลอรี่" },
        ]}
      },
      newItemMenu: {
        type: Object,
        value: {
          entries: [
            {name:"product", icon:"local-mall", title:"สินค้า" },
            {name:"article", icon:"local-library", title:"อาร์ติเคิล" },
            {name:"collection", icon:"group-work", title:"คอลเลคชั่น" },
            {name:"gallery", icon:"photo-library", title:"แกลเลอรี่" },
          ],
        }
      },
      visible: {
        type: Boolean,
        value: false,
      },

      route: {
        type: Object,
        notify: true,
        observer: '_routeChanged',
      },
      routeData: {
        type: Object,
        notify: true,
        observer: '_routeDataChanged',
      },
      subroute: Object,

      editor: {
        type: Object,
        observer: '_editorChanged',
      },

      selectedItemKey: {
        type: String,
      },
      selectedItemRole: {
        type: String,
        observer: '_selectedItemRoleChanged'
      },

      items: Object,
    }}

    _selectedItemRoleChanged(role) {
      this.set('editor', this.$[role+'-editor']);
    }

    static get observers() { return [
      '_itemsChanged(items.*)',
      '_uidSelectedItemKeyChanged(me.user.uid, selectedItemKey)',
      '_userChanged(me.user.uid)',
      '_visibleChanged(visible)',
    ]}

    _setCover(itemKey,imageKey) {
      if (!imageKey) {
        this._setPhotoKeyProperty(itemKey, '_src', 'images/logo-pumpkin-face-grayout.svg');
        return;
      }
      let thumbnail = MHA.get(['items',itemKey,'images',imageKey,'thumbnail']);
      if (thumbnail) {
        let uid = MHA.AU.currentUser.uid;
        MHA.registerRepresentation(thumbnail, { src: (key,src) => {
          this._setPhotoKeyProperty(itemKey, '_src', src);
        }});
      }
    }

    _formatLabel(str) {
      if (str) return str;
      return "(ไม่มีชื่อ)"
    }

    _itemsChanged(change) {
      let path = change.path.split('.');
      if (path.length < 2) return;
      let itemKey = path[1];

      if (this.editor && itemKey == this.editor.itemKey) {
        this.editor.updateChanges(path,change.value);
      }

      if (path.length == 3 && path[2] == 'cover') {
        this.itemList.every((item,index) => {
          if (itemKey == item.key) {
            this._setCover(itemKey,change.value);
            return false;
          }
          return true;
        });
      } else if (path.length == 5 && path[4] == 'thumbnail') {
        let imageKey = path[3];
        this.itemList.every((item,index) => {
          if (itemKey == item.key &&
            imageKey == MHA.get(['items',itemKey,'cover'])) {
            this._setCover(itemKey,imageKey);
            return false;
          }
          return true;
        });
      }

    }

    connectedCallback() {
      super.connectedCallback();
      window.addEventListener('close-contextual-menu', this._closeSubmenu.bind(this));
      this.menu.action = e => this._onSelectedItemType(e);
      this.newItemMenu.action = e => this._onNewItem(e);
    }

    _visibleChanged(visible) {
      if (visible) {
        this.setProperties({
          selectedItemKey: this.selectedItemKey || this._CurrentItemKey,
          selectedItemRole: this.selectedItemRole,
        });
      } else {
        this._CurrentItemKey = this.selectedItemKey;
        this.set('itemKey', null);
      }
    }

    _formatRoleIcon(role) {
      return MGIconForRole(role);
    }

    _formatImagesCount(images) {
      return images ? Object.entries(images).length: 0;
    }

    _userChanged(uid) {
      this.set('itemList',[]);
      if (this._UidChangedCallback) {
        this._UidChangedCallback.ref.off('child_added', this._UidChangedCallback.cb, this);
        delete this._UidChangedCallback;
      }
      if (uid) {
        this._UidChangedCallback = {ref:MHA.DB.ref('home').child(uid).child('items')};
        this._UidChangedCallback.cb
         = this._UidChangedCallback.ref.on('child_added', function(snapshot) {
          let val = snapshot.val();

          if( this.itemList.every(function(item){
            /* Check if item exists */
            return item.key != snapshot.key;
          })) {
            /* New item found in snapshot, insert into item list.
             * In expected case it may already add placeholders for keeping
             * items that are being constructed.
             */
            this.unshift('itemList',{
              key: snapshot.key,
              role: val.role,
              name: val.name,
              images: val.images,
            }) - 1;
          }

          val._uid = uid;
          MHA.assignItem(snapshot.key,val);

          let itemRef = MHA.DB.ref('home')
                              .child(uid)
                              .child('items')
                              .child(snapshot.key);

          /* Listen to name changes */
          itemRef.child('name').on('value', nameSnapshot => {
            this._setPhotoKeyProperty(snapshot.key, 'name', nameSnapshot.val());
          });

          /* Listen to images changes */
          itemRef.child('cover').on('value', coverSnapshot => {
              MHA.assignItem(snapshot.key,{cover:coverSnapshot.val()});
              this._setCover(snapshot.key, coverSnapshot.val());
          });

        },function(error){},this);
      }
    }

    _indexItem(itemKey) {
      for (let i = 0, data; data = this.itemList[i]; ++i) {
        if (data.key == itemKey) {
          return i;
        }
      }
      return -1;
    }

    _setPhotoKeyProperty(key,prop,val) {
      let idx = this._indexItem(key);
      if (idx > -1) {
        this.itemList[idx][prop] = val;
        this.notifyPath(['itemList',idx,prop]);
      }
    }

    _onThumbnailClick(e) {
      this.setProperties({
        selectedItemKey: e.model.item.key,
        selectedItemRole: e.model.item.role,
      });
      this.editor.set('itemKey',this.selectedItemKey);
    }

    _onSelectedItemType(e) {
      console.log("Not yet implemented. Should display only", e.model.item.name);
    }

    _editorChanged(newEditor, oldEditor) {
      if (oldEditor) {
        oldEditor.set('itemKey',null);
      }
      newEditor.set('itemKey',this.selectedItemKey);
    }

    _onNewItem(e) {
      this._closeSubmenu(e);
      if (e.model.item.name == 'gallery') {
        let key = MHA.DB.ref('items').push().key;
        this.setProperties({
          selectedItemKey: key,
          selectedItemRole: e.model.item.name,
        });
        this.editor.set('itemKey',this.selectedItemKey);
      }
    }

    _uidSelectedItemKeyChanged(uid, selectedItemKey) {
      if (this._ItemReference) {
        this._ItemReference.off('value', this._ItemCallback);
        delete this._ItemCallback;
        delete this._ItemReference;
      }

      if (!uid || !selectedItemKey) {
        return;
      }

      this._ItemReference = MHA.DB.ref('home').child(uid).child('items').child(selectedItemKey);
      this._ItemCallback = this._ItemReference.on('value', itemSS => {

        let v = itemSS.val();
        if (v) {
          if (!v.role) {
            /* If files got uploaded beforehand */
            return;
          }

          this.set('selectedItemRole',v.role);

          if (v.role != 'gallery') { this.set('galleryKey', null); }
          if (v.role != 'article') { this.set('articleKey', null); }
          if (v.role != 'product') { this.set('productKey', null); }
          if (v.role != 'collection') { this.set('collectionKey', null); }

          let item = {
            _uid: uid,
            name: v.name,
            role: v.role,
            time: v.time,
            cover: v.cover,
          }

          itemSS.child('images').forEach(imgRef => {
            let val = imgRef.val();

                item.images = item.images || {};
              item.images[imgRef.key] = item.images[imgRef.key] || val;
            item.images[imgRef.key].deleted = val.deleted || null;
            item.images[imgRef.key].roi = val.roi || null;

          });

          MHA.assignItem(itemSS.key,item);

        } else if (!this.selectedItemRole) {
          /* editorRole isn't defined. This is not creating a new item. */
          this.set('selectedItemKey', null);
          if (this.route) {
            this.set('route.path', '');
          }
        }

      }, error => {
        console.error("ERR", error);
        this._ItemReference.off('value', this.onItemSnapshot, this);
        delete this._ItemReference;
      });


      if (this.route) {
        this.set('route.path', selectedItemKey);
      }
    }

    _routeChanged(route) {
      if (route.prefix == '/user/items') {
        /* Checks if it was editing an item, set the URL back to the item */
        let key = this.selectedItemKey || this._CurrentItemKey;
        if (key && !route.path) {
          delete this._CurrentItemKey; /* Delete or it will keep bouncing back trying */
          this.set('route.path', key);
        }
      }
    }

    _routeDataChanged(routeData) {
      if (routeData.selectedItemKey) {
        this.set('selectedItemKey', routeData.selectedItemKey);
      }
    }

    disconnectedCallback() {
      delete this.newItemMenu.target;
      super.disconnectedCallback();
    }

    _closeSubmenu(e) {
      if (e.detail && e.detail.sender != this) {
        this.$['new-item-balloon'].close();
      }
    }

    /* XXX implement contextual behavior */
    _openNewItemMenu(e) {
      this.dispatchEvent(new CustomEvent('close-contextual-menu', {
        bubbles: true, composed: true, detail:{sender:this}
      }));

      if (this.$['new-item-balloon'].visible) {
        this.$['new-item-balloon'].close();
        return;
      }

      this.$['new-item-balloon'].positionTarget = this.$['new-item'];
      this.$['new-item-balloon'].open();
    }
  }
  customElements.define(MGItems.is, MGItems);
</script>
</dom-module>
