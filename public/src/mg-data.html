<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<dom-module id="mg-data">

<script src="https://www.gstatic.com/firebasejs/4.3.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/4.3.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/4.3.1/firebase-database.js"></script>
<script src="https://www.gstatic.com/firebasejs/4.3.1/firebase-storage.js"></script>
<script>

/* MHA stands for Moon HyunA */
var MHA = {
  items: {},

  representations: new Map(),

  registerRepresentation: function( keyOrBlob, srcCallback, contentType ) {
     /*XXX UID of other user */
    console.assert(keyOrBlob,"XXX");

    let key, blob = keyOrBlob instanceof Blob ? keyOrBlob : null;

    if (blob) {
        key = this.DB.ref('representations').push().key;
    } else {
      key = keyOrBlob;
    }

    let rep = this.representations.get(key);
    if (!rep) {
      rep = {contentType:contentType};
      this.representations.set(key, rep)
    }

    /* TODO
     * - Define a local status for JS generated images so they can be decided
     *   later if they'd actually require cloud storage.
    */

    if (blob) {
      let uid = this.AU.currentUser.uid;

      /* Task begin. Upload the blob onto storage. */
      let repSTRef = this.ST.ref('UID').child(uid).child('DATA').child(key);

      let metadata = {
        contentType: contentType || 'image/jpeg',
      }

      let task = repSTRef.put(blob,metadata);
      let taskEnded = false;

      /* If uploader didn't specify srcCallback then _callbacks could be empty.
       * It sill allocates an empty list to prevent another registration from solving
       * URL as it's going to use the given Blob as source.
       */
      //console.assert(!rep._callbacks, "_callbacks already exists, reupload isn't correctly implemented yet.");
      rep._callbacks = rep._callbacks || [];
      if (srcCallback) {
        /* expose task once to the uploading call */
        if (srcCallback.task) srcCallback.task(key, task);

        rep._callbacks.push(srcCallback);
      }

      task.on( firebase.storage.TaskEvent.STATE_CHANGED, snapshot => {
          rep._callbacks.forEach(function(cb){
            if (cb.progress) cb.progress(key,snapshot);
          });
        }, error => {
          rep._callbacks.forEach(function(cb){
            if (cb.error) cb.error(key,error);
          });
        }, () => {

          let registerData = {
            ['representations/'+key+'/uid']: uid,
          };

          this.DB.ref().update(registerData, error => {

            rep._callbacks.forEach(function(cb){
              if (cb.complete) cb.complete(key,error);
            });

            if (rep.src) {
              /* Whichever done last must delete the callbacks, existing src means
               * that the reader already solved it.
               */
              delete rep._callbacks;
            }

            taskEnded = true;
          });

        }
      ); /*End of uploading task*/

      /* Read blob as src and create thumbnail */
      var reader = new FileReader();
      reader.onload = e => {


        rep.src = e.target.result;

        rep._callbacks.forEach(function(cb){
          if (cb.src) cb.src(key, e.target.result)
          else if (typeof cb === 'function') cb(key, 'src', e.target.result);
        });

        if (taskEnded) {
          delete rep._callbacks;
        }
      };
      reader.readAsDataURL(blob);

    } /* end if(blob) */
    else if (srcCallback) {
      if (rep._callbacks) {
        /* _callbacks exists, it could be either getting src or an uploading in progress. */
        if (rep.src) {
          /* if src was resolved, just call it a day */
          if (srcCallback.src) srcCallback.src(key, rep.src);
        } else {
          /* or join the waiting campfire */
          rep._callbacks.push(srcCallback);
        }
      } else if (!rep.src) {
        /* no callback and no src, so no chance it is getting src, so let's get it now */
        rep._callbacks = [srcCallback];

        this.DB.ref('representations').child(key).child('uid').once('value', snapshot => {
          let uid = snapshot.val();
          if (uid) {
            let repSTRef = this.ST.ref('UID').child(uid).child('DATA').child(key);
            repSTRef.getDownloadURL().then(url => {
              rep.src = url;
              rep._callbacks.forEach(function(cb){
                if (cb.src) cb.src(key,url);
              });
              delete rep._callbacks;
            }).catch(error => {
              /* This might have been invoked before the upload task started by any following registerRep call.
               * Please don't do that!
               */
              console.warn(`Representation src for ${key} does not exist. Callback has not been released.`,error);
            });
          }

          console.assert(uid, key, "XXX UID not found, should wait?");

        });
      } else /* src has been resolved */ {
        if (srcCallback.src) srcCallback.src(key, rep.src);
      }
    }

    if (srcCallback && srcCallback.key) srcCallback.key(key,key);

    /* return function to unsubscribe srcCallback */
    return function(){
      if (rep._callbacks) {
        let idx = rep._callbacks.indexOf(srcCallback);
        if (idx >= 0) {
          rep._callbacks[idx] = {};
        }
      }
    };

  },

  setItem: function(itemKey, itemData, sync) {
    if (sync) {
      let registerData;
      let syncFunc = (path,value) => {

        if(path.slice(-1) == '$' || typeof value === 'undefined') {
          return [path,value]; /* Resign the replacer for any path end with $ */
        }

        if (value === null || Array.isArray(value) || typeof value !== 'object') {
          if (MHA.data.get(path) !== value) {
            if (!registerData) {
              registerData = {[path.split('.').join('/')]: value};
            } else {
              registerData[path.split('.').join('/')] = value;
            }
          }
        }

        return;
      };

      this.utils.deepSet(MHA.data, 'items.'+itemKey, itemData, syncFunc('items.'+itemKey, itemData));

      if (this.AU.currentUser && registerData) {
        this.DB.ref('home').child(this.AU.currentUser.uid).update(registerData, error => {
          console.log('Synced.',registerData);
        });
      }

    } else {
      this.utils.deepSet(MHA.data, 'items.'+itemKey, itemData);
    }
  },

  getItem: function(target,fillTarget) {
    if (fillTarget) {
      this.utils.deepGet(target, this.items, fill);
      return target;
    }

    return this.utils.deepGet(target, this.items);
  },

  get: function(path) {
    return this.data ? this.data.get(path) : null;
  },

  /* TODO make a behavior of this */
  utils: {
    deepGet(target, source, fill) {
      for (let p in target) {
        if (source[p] && target[p] === null) {
          if (fill) {
            target[p] = source[p];
          } else {
            return source[p];
          }
        } else if (typeof source[p] !== 'undefined') {
          if (fill) {
            _(target[p], source[p], true);
          } else {
            return this.deepGet(target[p], source[p]);
          }
        }
      }

      return null;
    },
    /* deepSet is used to set a deep property of a Polymer Object.
     * It only supports object in a path and scalar array.
     * It can not be used to set a particular array item.
     * To delete a deep property, set null as the counter-value
     * in the structure of the object argument.
     *
     * replacer : A callback that can be optionally specified to override
     * the given path/values. It returns an array for new path,value,replacer
     * or undefined for observation purpose.
     */
    deepSet(polymerElement, path, value, replacer) {
      /* XXX Why does it need this? */
      if (typeof value === 'undefined') {
        return;
      }

      if (replacer) {
        let replacing = replacer(path,value);
        if (replacing) {
          [path,value,replacer] = replacing;
        }
      }

      if (Array.isArray(value)) {

        /* Handle scalar array */
        let old = polymerElement.get(path);
        if (!Array.isArray(old)
        || old.length != value.length
        || !old.every((v,i) => v === value[i])) {
          /* Only set if not equal */
          polymerElement.set(path, value);
        }
      } else if (typeof value !== 'object' || value === null) {
          polymerElement.set(path, value);
      } else {
        oldValue = polymerElement.get(path);
        if (typeof oldValue !== 'object' || oldValue === null || Array.isArray(oldValue)) {
          /* Overwrite non-object and to create a readable placeholder */
          polymerElement.set(path, {});
        }
        Object.keys(value).forEach(key => {
          this.deepSet(polymerElement, path+'.'+key, value[key], replacer);
        });
      }

    },
    deepStruct(path,value) {
      let paths = Polymer.Path.split(path);
      let tree = {};
      let miner = tree;
      while (paths.length > 1) {
        miner[paths[0]] = {};
        miner = miner[paths[0]];
        paths.shift();
      }
      miner[paths[0]] = value;
      return tree;
    },
  },
};


if (!MHA.APP) {

  let config = {
    apiKey: "AIzaSyDyJuzvmpg4jRPs9VE_Mpne8vdysEZGxbo",
    authDomain: "be-booed.firebaseapp.com",
    databaseURL: "https://be-booed.firebaseio.com",
    projectId: "be-booed",
    storageBucket: "be-booed.appspot.com",
    messagingSenderId: "1079409265314"
  };

  MHA.APP = firebase.initializeApp(config);
  MHA.DB = MHA.APP.database();
  MHA.ST = MHA.APP.storage();
  MHA.AU = MHA.APP.auth();
}

(function() {
let __MGDataInstances = [];
let __MGDataNotifierStates = new Map();

class MGData extends Polymer.Element {


  static get is() { return 'mg-data'; }

  static get properties() { return {
    /* Items here is for caching known snapshot of items to distribute
    change notifications but the listening will only be in mg-items and to
    specific items currently on display */
    items: {
      type: Object,
      value: MHA.items,
      notify: true,
    },

  }}

  /* should try to use linkPaths */
  static get observers() { return [
    '_dataChanged(items.*)',
  ]}

  constructor() {
    super();
  }

  connectedCallback() {
    super.connectedCallback();
    __MGDataInstances.push(this);
    if (!MHA.data) MHA.data = this;
  }

  disconnectedCallback() {
    __MGDataInstances.splice(__MGDataInstances.indexOf(this),1);
    super.disconnectedCallback();
  }

  /* Didn't test, it should work :-P */
  _dataChanged(change) {
    let notifyState = __MGDataNotifierStates.get(change.path);
    if (!notifyState
      /* No state exists. Takes the lead. */
      || (notifyState.target != this && change.value !== notifyState.value)) {
      /* Or got a reentrance with an update to an actively notified path. */
      __MGDataNotifierStates.set(change.path, {value: change.value, target: this});
      __MGDataInstances.forEach(data => {
        if (data != this) {
          data.notifyPath(change.path);
        }
      });
      __MGDataNotifierStates.delete(change.path);
    }
  }

}

customElements.define(MGData.is, MGData);
})();

</script>
</dom-module>
