<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/app-localize-behavior/app-localize-behavior.html">

    <dom-module id="mg-data">
  <script src="https://www.gstatic.com/firebasejs/4.3.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/4.3.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/4.3.1/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/4.3.1/firebase-storage.js"></script>
  <script>
/* MHA stands for Moon HyunA */
var MHA = {
  items: {},

  configurations: {
    language: 'th',
  },

  representations: new Map(),
  dataInstances: new Map(),
  dataNotifierStates: new Map(),

  addInstance: function(path, instance) {
    let instances = this.dataInstances.get(path);
    if (!instances) {
      instances = new Set();
      this.dataInstances.set(path, instances);
    }
    instances.add(instance);
  },

  removeInstance: function(path, instance) {
    let instances = this.dataInstances.get(path);
    instances.delete(instance);
  },

  notifyInstances: function(instance, path, value) {
    let notifyState = this.dataNotifierStates.get(path);
    if (!notifyState /* No state exists. Takes the lead. */
      || (notifyState.target != instance && value !== notifyState.value)) {
      /* Or got a reentrance with an update to an active path. */
      this.dataNotifierStates.set(path, {value: value, target: instance});
      this.dataInstances.forEach((instances, activePath) => {
        if (path.startsWith(activePath)) {
          instances.forEach(sibling => {
            if (sibling != instance) {
              sibling.notifyPath(path);
            }
          });
        }
      });

      /* Only delete if state was not updated by other instances. */
      notifyState = this.dataNotifierStates.get(path);
      if (notifyState && notifyState.target == instance && notifyState.value == value) {
        this.dataNotifierStates.delete(path);
      }
    }
  },

  translations: (function() {
    let required_words = {
      'en': {
        'new-releases': 'new-releases',
        'recommendations': 'recommendations',
        'dress': 'dresses',
        'nightwear': 'nightwears',
        'lingerie': 'lingeries',
        'swimwear': 'swimwears',
        'sales': 'sales',
        'profile': 'profile',
        'orders': 'orders',
        'items': 'items',
        'store': 'store',
        'inbox': 'inbox',
        'help': 'help',
        'signin': 'sign in',
        'signout': 'sign out',
        'create item': 'create item',
        'create': 'create',
        'product': 'product',
        'products': 'products',
        'article': 'article',
        'articles': 'articles',
        'collection': 'collection',
        'collections': 'collections',
        'gallery': 'gallery',
        'galleries': 'galleries',
        'tos': 'TOS',
        'policy': 'policy',
        'icons': 'icons',
      }
    };

    required_words.jp = Object.assign({}, required_words.en, {
      'new-releases': 'リアタイ่',
      'recommendations': 'おすすめ商品',
      'dress': 'ドレス',
      'nightwear': 'ナイトウェア',
      'lingerie': 'ランジェリー',
      'swimwear': '水着',
      'sales': 'sales',
      'profile': '個人情報',
      'orders': '注文確認',
      'items': '項目',
      'store': '店舗',
      'inbox': 'プライベート メッセージ',
      'help': 'ヘルプ',
    });

    required_words.ko = Object.assign({}, required_words.en, {
      'new-releases': 'リアタイ่',
      'recommendations': '추천',
      'dress': '드레스',
      'nightwear': '나이트가운',
      'lingerie': '란제리',
      'swimwear': '수영복',
      'sales': 'sale',
      'profile': '프로필',
      'orders': '주문내역',
      'items': '아이템',
      'store': '가게',
      'inbox': '메시지',
      'help': '도움말',
    });

    required_words.th = Object.assign({}, required_words.en, {
      'new-releases': 'มาใหม่',
      'recommendations': 'แนะนำ',
      'dress': 'ชุดทั่วไป',
      'nightwear': 'ชุดนอน',
      'lingerie': 'ชุดชั้นใน',
      'swimwear': 'ชุดว่ายน้ำ',
      'sales': 'เซล',
      'profile': 'โพรไฟล์',
      'orders': 'รายการสั่งซื้อ',
      'items': 'ไอเท็ม',
      'store': 'ร้าน',
      'inbox': 'กล่องข้อความ',
      'help': 'ความช่วยเหลือ',
      'signin': 'เข้าสู่ระบบ',
      'signout': 'ออกจากระบบ',
      'create item': 'สร้างไอเท็ม',
      'create': 'สร้าง',
      'product': 'สินค้า',
      'products': 'สินค้า',
      'article': 'บทความ',
      'articles': 'บทความ',
      'collection': 'คอลเล็กชั่น',
      'collections': 'คอลเล็กชั่น',
      'gallery': 'แกลเลอรี่',
      'galleries': 'แกลเลอรี่',
      'tos': 'เงื่อนไขการให้บริการ',
      'policy': 'นโยบายความเป็นส่วนตัว',
      'icons': 'ไอค่อน',
    });

    required_words.zh = Object.assign({}, required_words.en, {
    });

    return required_words;
  })(),

  registerRepresentation: function( keyOrBlob, srcCallback, contentType ) {
     /*XXX UID of other user */
    console.assert(keyOrBlob,"XXX");

    let key, blob = keyOrBlob instanceof Blob ? keyOrBlob : null;

    if (blob) {
        key = this.DB.ref('representations').push().key;
    } else {
      key = keyOrBlob;
    }

    let rep = this.representations.get(key);
    if (!rep) {
      rep = {contentType:contentType};
      this.representations.set(key, rep)
    }

    /* TODO
     * - Define a local status for JS generated images so they can be decided
     *   later if they'd actually require cloud storage.
    */

    if (blob) {
      let uid = this.AU.currentUser.uid;

      /* Task begin. Upload the blob onto storage. */
      let repSTRef = this.ST.ref('UID').child(uid).child('DATA').child(key);

      let metadata = {
        contentType: contentType || 'image/jpeg',
      }

      let task = repSTRef.put(blob,metadata);
      let taskEnded = false;

      /* If uploader didn't specify srcCallback then _callbacks could be empty.
       * It sill allocates an empty list to prevent another registration from solving
       * URL as it's going to use the given Blob as source.
       */
      //console.assert(!rep._callbacks, "_callbacks already exists, reupload isn't correctly implemented yet.");
      rep._callbacks = rep._callbacks || [];
      if (srcCallback) {
        /* expose task once to the uploading call */
        if (srcCallback.task) srcCallback.task(key, task);

        rep._callbacks.push(srcCallback);
      }

      task.on( firebase.storage.TaskEvent.STATE_CHANGED, snapshot => {
          rep._callbacks.forEach(function(cb){
            if (cb.progress) cb.progress(key,snapshot);
          });
        }, error => {
          rep._callbacks.forEach(function(cb){
            if (cb.error) cb.error(key,error);
          });
        }, () => {

          let registerData = {
            ['representations/'+key+'/uid']: uid,
          };

          this.DB.ref().update(registerData, error => {

            rep._callbacks.forEach(function(cb){
              if (cb.complete) cb.complete(key,error);
            });

            if (rep.src) {
              /* Whichever done last must delete the callbacks, existing src means
               * that the reader already solved it.
               */
              delete rep._callbacks;
            }

            taskEnded = true;
          });

        }
      ); /*End of uploading task*/

      /* Read blob as src and create thumbnail */
      var reader = new FileReader();
      reader.onload = e => {


        rep.src = e.target.result;

        rep._callbacks.forEach(function(cb){
          if (cb.src) cb.src(key, e.target.result)
          else if (typeof cb === 'function') cb(key, 'src', e.target.result);
        });

        if (taskEnded) {
          delete rep._callbacks;
        }
      };
      reader.readAsDataURL(blob);

    } /* end if(blob) */
    else if (srcCallback) {
      if (rep._callbacks) {
        /* _callbacks exists, it could be either getting src or an uploading in progress. */
        if (rep.src) {
          /* if src was resolved, just call it a day */
          if (srcCallback.src) srcCallback.src(key, rep.src);
        } else {
          /* or join the waiting campfire */
          rep._callbacks.push(srcCallback);
        }
      } else if (!rep.src) {
        /* no callback and no src, so no chance it is getting src, so let's get it now */
        rep._callbacks = [srcCallback];

        this.DB.ref('representations').child(key).child('uid').once('value', snapshot => {
          let uid = snapshot.val();
          if (uid) {
            let repSTRef = this.ST.ref('UID').child(uid).child('DATA').child(key);
            repSTRef.getDownloadURL().then(url => {
              rep.src = url;
              rep._callbacks.forEach(function(cb){
                if (cb.src) cb.src(key,url);
              });
              delete rep._callbacks;
            }).catch(error => {
              /* This might have been invoked before the upload task started by any following registerRep call.
               * Please don't do that!
               */
              console.warn(`Representation src for ${key} does not exist. Callback has not been released.`,error);
            });
          }

          console.assert(uid, key, "XXX UID not found, should wait?");

        });
      } else /* src has been resolved */ {
        if (srcCallback.src) srcCallback.src(key, rep.src);
      }
    }

    if (srcCallback && srcCallback.key) srcCallback.key(key,key);

    /* return function to unsubscribe srcCallback */
    return function(){
      if (rep._callbacks) {
        let idx = rep._callbacks.indexOf(srcCallback);
        if (idx >= 0) {
          rep._callbacks[idx] = {};
        }
      }
    };

  },

  /* setItem : Set an item for current user
   * itemKey : Item key of the item.
   * itemData : Data tree of objects & arrays to be set for the item.
   * sync : Should sync database server. Paths end with $ will be excluded.
   */

  setItem: function(itemKey, itemData, sync) {
    if (sync) {
      let registerData;
      let syncFunc = (path,value) => {

        if(path.slice(-1) == '$' || typeof value === 'undefined') {
          return [path,value]; /* Resign the replacer for any path end with $ */
        }

        if (value === null || Array.isArray(value) || typeof value !== 'object') {
          if (this.get(path) !== value) {
            if (!registerData) {
              registerData = {[path.split('.').join('/')]: value};
            } else {
              registerData[path.split('.').join('/')] = value;
            }
          }
        }

        return;
      };

      this.Path.deepSet(this, 'items.'+itemKey, itemData, syncFunc);

      if (this.AU.currentUser && registerData) {
        this.DB.ref('home').child(this.AU.currentUser.uid).update(registerData, error => {
          console.log('Synced.',registerData);
        });
      }

    } else {
      this.Path.deepSet(this, 'items.'+itemKey, itemData);
    }
  },

  getItem: function(target, fillTarget) {
    if (fillTarget) {
      this.Path.deepGet(target, this.items, true);
      return target;
    }

    return this.Path.deepGet(target, this.items);
  },

  set: function(path, value) {
    let v = this.get(path);
    if (v !== value) {
      /* XXX Filter ...$ ? */
      this.Path.deepStruct(this, path, value);
      if (!path.endsWith('$')) { /* Struct$ will leak, but better forbid them */
        this.notifyInstances(this, path, value);
      }
    }
  },

  get: function(path) {
    return this.Path.deepGet(this.Path.deepStruct({}, path, null), this);
  },

  /* TODO make a behavior of this */
  Path: {
    deepGet(target, source, fill) {
      for (let p in target) {
        if (source[p] && target[p] === null) {
          if (fill) {
            target[p] = source[p];
          } else {
            return source[p];
          }
        } else if (typeof source[p] !== 'undefined') {
          if (fill) {
            _(target[p], source[p], true);
          } else {
            return this.deepGet(target[p], source[p]);
          }
        }
      }

      return undefined;
    },
    /* deepSet is used to set a deep property of a Polymer Object.
     * It only supports object in a path and scalar array.
     * It can not be used to set a particular array item.
     * To delete a deep property, set null as the counter-value
     * in the structure of the object argument.
     *
     * data : must implement set(path,value) that will trigger bindings.
     *
     * replacer : A callback that can be optionally specified to override
     * the given path/values. It returns an array for new path,value,replacer
     * or undefined for observation purpose.
     */
    deepSet(data, path, value, replacer) {
      /* values may be set to undefined to dissociate itself from
       * any previously updated key while null will be used to delete values.
       * So undefined values will simply be ignored.
       */
      if (typeof value === 'undefined') {
        return;
      }

      if (replacer) {
        let replacing = replacer(path,value);
        if (replacing) {
          [path,value,replacer] = replacing;
        }
      }

      if (Array.isArray(value)) {

        /* Handle scalar array */
        let old = data.get(path);
        if (!Array.isArray(old)
        || old.length != value.length
        || !old.every((v,i) => v === value[i])) {
          /* Only set if not equal */
          data.set(path, value);
        }
      } else if (typeof value !== 'object' || value === null) {
          data.set(path, value);
      } else {
        oldValue = data.get(path);
        if (typeof oldValue !== 'object' || oldValue === null || Array.isArray(oldValue)) {
          /* Overwrite non-object and to create a readable placeholder */
          data.set(path, {});
        }
        Object.keys(value).forEach(key => {
          this.deepSet(data, path+'.'+key, value[key], replacer);
        });
      }

    },

    /* deepStruct sets tree's missing path with value.
     */
    deepStruct(tree,path,value) {
      let paths = Polymer.Path.split(path);
      let miner = tree;
      let pval = paths.pop();
      let p;
      while ((p = paths.shift()) !== undefined) {
        miner[p] = miner[p] || {};
        miner = miner[p];
      }
      miner[pval] = value;
      return tree;
    },
  },

};

if (!MHA.APP) {

  let config = {
    apiKey: "AIzaSyDyJuzvmpg4jRPs9VE_Mpne8vdysEZGxbo",
    authDomain: "be-booed.firebaseapp.com",
    databaseURL: "https://be-booed.firebaseio.com",
    projectId: "be-booed",
    storageBucket: "be-booed.appspot.com",
    messagingSenderId: "1079409265314"
  };

  MHA.APP = firebase.initializeApp(config);
  MHA.DB = MHA.APP.database();
  MHA.ST = MHA.APP.storage();
  MHA.AU = MHA.APP.auth();
}

(function() {
class MGData extends Polymer.Element {

  static get is() { return 'mg-data'; }

  static get properties() { return {
    /* Items here is for caching known snapshot of items to distribute
    change notifications but the listening will only be in mg-items and to
    specific items currently on display */
    items: {
      type: Object,
      value: MHA.items,
      notify: true,
    },

    configurations: {
      type: Object,
      value: MHA.configurations,
      notify: true,
    },

  }}

  /* should try to use linkPaths */
  static get observers() { return [
    '_dataChanged(items.*)',
    '_dataChanged(configurations.*)',
  ]}

  constructor() {
    super();
  }

  connectedCallback() {
    super.connectedCallback();
    MHA.addInstance('items.',this);
    MHA.addInstance('configurations.',this);
  }

  disconnectedCallback() {
    MHA.removeInstance('items.',this);
    MHA.removeInstance('configurations.',this);
    super.disconnectedCallback();
  }

  /* Didn't test, it should work :-P */
  _dataChanged(change) {
    MHA.notifyInstances( this, change.path, change.value );
  }

}

MHA.Configurations = (superClass) => { return class extends Polymer.mixinBehaviors([Polymer.AppLocalizeBehavior],superClass) {
  static get properties() { return {
    configurations: {
      value: MHA.configurations,
    },
    language: String,
    resources: Object,
  }}

  static get observers() { return [
    '__languageChanged(configurations.language)',
    '__configurationsChanged(configurations.*)',
  ]}

  constructor() {
    super();
    this.resources = MHA.translations;
  }

  connectedCallback() {
    super.connectedCallback();
    MHA.addInstance('configurations.', this);
  }

  disconnectedCallback() {
    MHA.removeInstance('configurations.', this);
    super.disconnectedCallback();
  }

  __languageChanged(language) {
    this.set('language',language);
  }
  __configurationsChanged(change) {
    MHA.notifyInstances(this, change.path, change.value);
  }
}}

MHA.Items = (superClass) => { return class extends superClass {
  static get properties() { return {
    items: {
      value: MHA.items,
    },
  }}

  static get observers() { return [
    '__itemsChanged(items.*)',
  ]}

  constructor() {
    super();
    this.resources = MHA.translations;
  }

  connectedCallback() {
    super.connectedCallback();
    MHA.addInstance('items.', this);
  }

  disconnectedCallback() {
    MHA.removeInstance('items.', this);
    super.disconnectedCallback();
  }

  __itemsChanged(change) {
    MHA.notifyInstances(this, change.path, change.value);
  }
}}

customElements.define(MGData.is, MGData);
})();

  </script>
    </dom-module>
