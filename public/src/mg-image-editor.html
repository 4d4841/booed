<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/iron-image/iron-image.html">
<link rel="import" href="mg-common-styles.html">



<dom-module id="mg-image-editor">
  <template strip-whitespace>
      <custom-style>
    <style include="mg-common-styles iron-flex iron-flex-alignment">

      :host {
        display: none;
        position: absolute;
        width: 0;
        height: 0;
        @apply(--layout-horizontal);
        @apply(--layout-center-justified);
        @apply(--layout-center);
        background-color: black;
        opacity: 0;
        transition: opacity 0.5s;
        z-index:-1;
      }

      :host([active]) {
        display: block;
        position: fixed;
        z-index:1000;
        width:100%;
        height:100%;
        top: 0;
        left: 0;
        display: block;
        @apply(--layout-horizontal);
        @apply(--layout-center-justified);
        @apply(--layout-center);
      }


      #canvas {
        background-size: contain;
      }

      /*
      #image-container {
        height: calc(100% - 120px);
        width: calc(100% - 60px);
        border: 1px solid red;
        pointer-events: none;
      }
      */


    </style>
      </custom-style>

    <paper-icon-button icon="cancel" style="position:absolute;top:5px;right:5px;color:white" on-tap="_deactivate">
    </paper-icon-button>


<!--
    <iron-image id="image-container" sizing="contain" src="[[src]]" placeholder="/images/logo-bounce.svg">
    </iron-image>
    <svg id="canvas" width="200px" height="200px" on-track="_onTrack">
    </svg>
  -->

  <template is="dom-if" if="[[loading]]">
    <img style="position:absolute" width="200px" height="200px" src="/images/logo-pumpkin-bouncing.svg">
  </template>

<svg
   xmlns:svg="http://www.w3.org/2000/svg"
   xmlns="http://www.w3.org/2000/svg"
   xmlns:xlink="http://www.w3.org/1999/xlink"
   id="canvas"
   on-track="_onTrack"
   version="1.1"
   viewBox="0 0 200 200"
   preserveAspectRatio="none"
   width="0"
   height="0"
   hidden$="[[loading]]">

   <defs>
     <path id="chevrons" d="M -2.6,4.6 -7.2,0 -2.6,-4.6 -4,-6 -10,0 -4,6 Z M 2.6,4.6 7.2,0 2.6,-4.6 4,-6 10,0 4,6 Z" style$="[[_styleArrow(tracking)]]"/>
   </defs>

   <path d$="[[rPath]]" fill="rgba(0,0,0,0.9)" stroke="none"/>

   <use xlink:href="#chevrons" transform$="[[_formatTranslate(scaleFactor,rMidX,rTop,90)]]" />
   <use xlink:href="#chevrons" transform$="[[_formatTranslate(scaleFactor,rLeft,rMidY)]]" />
   <use xlink:href="#chevrons" transform$="[[_formatTranslate(scaleFactor,rMidX,rBottom,90)]]" />
   <use xlink:href="#chevrons" transform$="[[_formatTranslate(scaleFactor,rRight,rMidY)]]" />

</svg>


  </template>
  <script>
    class MGImageEditor extends Polymer.GestureEventListeners(
      Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element)
    ) {
      static get is() { return 'mg-image-editor'; }

      static get properties() { return {
        rep: {
          type: String,
          notify: true,
          observer: '_repChanged',
        },

        src: {
          type: String,
          observer: '_srcChanged',
          value: null,
        },

        active: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
        },

        imageWidth: { type: Number, value: 0 },
        imageHeight: { type: Number, value: 0 },
        viewWidth: { type:Number, value: 0 },
        viewHeight: { type:Number, value: 0 },

        rLeft: { type: Number, value: 0 },
        rTop: { type: Number, value: 0 },
        rWidth: { type: Number, value: 0 },
        rHeight: { type: Number, value: 0 },
        scaleFactor: { type: Number, value: 1 },
        rPath: {
          type: String,
          value: "M 0 0 v 0 h 0 v -0 Z",
        },

        loading: Boolean,

        tracking: {
          type: Object,
          value: null,
        },
      }}

      static get observers() { return [
        '_rChanged(rLeft, rTop, rWidth, rHeight)'
      ]}

      _styleArrow(tracking) {
        return tracking ? 'fill:none;stroke:none' : 'fill:white;stroke-width:1;stroke:black';
      }

      _formatTranslate(s,x,y,r) {
        x = x || 0;
        y = y || 0;
        r = r || 0;

        let ret = `translate(${x},${y})`;
        if (r) ret += ` rotate(${r})`;
        ret+= ` scale(${1.2*s})`;

        return ret;
      }

      _rChanged(rLeft, rTop, rWidth, rHeight) {
        this.set('rMidX', rLeft + rWidth/2);
        this.set('rMidY', rTop + rHeight/2);
        this.set('rRight', rLeft + rWidth);
        this.set('rBottom', rTop + rHeight);

        this.set('rPath',`M 0 0 v ${this.imageHeight} h ${this.imageWidth} v -${this.imageHeight} Z M ${rLeft} ${rTop} h ${rWidth} v ${rHeight} h -${rWidth} Z`);

      }

      connectedCallback(){
        super.connectedCallback();
        //Polymer.Gestures.addListener(this, 'track', e => this._onTrack(e));

        this.csize = '40px';
        this.addEventListener('iron-resize', e => {
          //console.log('resize', e);
          //console.log('wh',this.offsetWidth, this.offsetHeight);
          this._setImageWH( this.imageWidth, this.imageHeight );
        },true);
      }

      _setImageWH(w,h) {
        if (!w || !h) return;

        let vw = this.offsetWidth - 60;
        let vh = this.offsetHeight - 120;

        if (vw < 0 || vh < 0) return;

        if (w/h > vw/vh) {
          vh = vw * h/w;
        } else {
          vw = vh * w/h;
        }

        this.set('viewWidth',vw);
        this.set('viewHeight',vh);
        this.set('imageWidth',w);
        this.set('imageHeight',h);

        this.$.canvas.setAttribute('width', vw);
        this.$.canvas.setAttribute('height', vh);
        this.$.canvas.setAttribute('viewBox',`0 0 ${w} ${h}`);

        this.set('canvasBB', this.$.canvas.getBoundingClientRect());
        this.set('scaleFactor', this.viewWidth ? this.imageWidth/this.viewWidth : 1);

      }

      _onTrack(e) {
        let cx = this.scaleFactor * (e.detail.x - this.canvasBB.left);
        let cy = this.scaleFactor * (e.detail.y - this.canvasBB.top);
        let dx = this.scaleFactor * e.detail.ddx;
        let dy = this.scaleFactor * e.detail.ddy;
        let bw = 40; /* grabbable border */

        switch (e.detail.state) {
          case 'start':
            this.tracking = {l: 0, t: 0, w: 0, h: 0};
            if (cx >= this.rLeft + bw && cx < this.rRight - bw
              && cy >= this.rTop + bw && cy < this.rBottom - bw) {
              this.tracking.l = 1;
              this.tracking.t = 1;
            } else {
              if (cx < this.rLeft + bw) {
                this.tracking.l = 1;
                this.tracking.w = 1;
              } else if (cx >= this.rRight - bw) {
                this.tracking.w = -1;
              }

              if (cy < this.rTop + bw) {
                this.tracking.t = 1;
                this.tracking.h = 1;
              } else if (cy >= this.rBottom - bw) {
                this.tracking.h = -1;
              }
            }
            break;
          case 'end':
            this.set('tracking', null);
            break;
          case 'track':

            /* XXXX hack to clear selection */
            if ( document.selection ) {
              document.selection.empty();
            } else if ( window.getSelection ) {
              window.getSelection().removeAllRanges();
            }

            if (this.tracking.l) {
              let rl = this.rLeft + dx;
              this.set('rLeft', rl > this.imageWidth ? this.imageWidth : rl);
            }
            if (this.tracking.t) {
              let rt = this.rTop + dy;
              this.set('rTop', rt > this.imageHeight ? this.imageHeight : rt);
            }
            if (this.tracking.w) {
              let rw = this.rWidth - dx * this.tracking.w;
              this.set('rWidth', rw < 0 ? 0 : rw);
            }
            if (this.tracking.h) {
              let rh = this.rHeight - dy * this.tracking.h;
              this.set('rHeight', rh < 0 ? 0 : rh);
            }


            if (this.rLeft < 0) {
              let rw = this.rWidth + this.rLeft;
              this.set('rWidth', rw < 0 ? 0 : rw);
              this.set('rLeft', 0);
            } else if (this.rLeft + this.rWidth > this.imageWidth) {
              let rw = this.imageWidth - this.rLeft;
              this.set('rWidth', rw < 0 ? 0 : rw);
            }

            if (this.rTop < 0) {
              let rh = this.rHeight + this.rTop;
              this.set('rHeight', rh < 0 ? 0 : rh);
              this.set('rTop', 0);
            } else if (this.rTop + this.rHeight > this.imageHeight) {
              let rh = this.imageHeight - this.rTop;
              this.set('rHeight', rh < 0 ? 0 : rh);
            }

            break;
        }
        /*
        this.set('rWidth',cx > 0 ? cx : 0);
        this.set('rHeight',cy > 0 ? cy : 0);
        */
      }

      _onImageLoaded(e) {
        this.set('loading', false);
        this._setImageWH(e.path[0].width,e.path[0].height);
        this.set('rLeft',0);
        this.set('rTop',0);
        this.set('rWidth',this.imageWidth);
        this.set('rHeight',this.imageHeight);

        this.set('src',e.path[0].src);
      }

      _srcChanged(src) {
        this.$.canvas.style.backgroundImage = `url(${src})`;
      }

      _repChanged(rep) {
        if (rep) {
          this.set('active',true);
          this.style.opacity = 1;
          this.set('loading', true);
          MGAPP.registerRepresentation(rep, (key,ev,val) => {
            if (key == this.rep) {
               let img = new Image();
               img.onload = e => this._onImageLoaded(e);
               img.src = val;
            }
          });
        } else {
          this.set('src',null);
          this.set('active',false);

          this.$.canvas.setAttribute('viewBox','0 0 200 200');
          this.$.canvas.setAttribute('width', 200);
          this.$.canvas.setAttribute('height', 200);
          this.set('rLeft',0);
          this.set('rTop',0);
          this.set('rWidth',200);
          this.set('rHeight',200);
        }
      }

      _test(e) {
        console.log(e);
      }

      _deactivate(e) {
        this.style.opacity = 0;
        Polymer.Async.timeOut.run(() => {
          this.set('rep',null);
        }, 500);
      }

    }

    customElements.define(MGImageEditor.is, MGImageEditor);
  </script>
</dom-module>
