<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/iron-image/iron-image.html">
<link rel="import" href="mg-common-styles.html">



<dom-module id="mg-image-editor">
  <template strip-whitespace>
      <custom-style>
    <style include="mg-common-styles iron-flex iron-flex-alignment">

      :host {
        display: none;
        position: absolute;
        width: 0;
        height: 0;
        @apply(--layout-horizontal);
        @apply(--layout-center-justified);
        @apply(--layout-center);
        background-color: black;
        opacity: 0;
        transition: opacity 0.5s;
        z-index:-1;
      }

      :host([active]) {
        display: block;
        position: fixed;
        z-index:1000;
        width:100%;
        height:100%;
        top: 0;
        left: 0;
        display: block;
        @apply(--layout-horizontal);
        @apply(--layout-center-justified);
        @apply(--layout-center);
      }

      .image-info {
        color: lightgray;
        position: absolute;
        top: 0;
        left: 0;
      }

      .close-button {
        position: absolute;
        top: 5px;
        right: 5px;
        color: lightgray;
      }

      #canvas {
        background-size: contain;
      }

      /*
      #image-container {
        height: calc(100% - 120px);
        width: calc(100% - 60px);
        border: 1px solid red;
        pointer-events: none;
      }
      */


    </style>
      </custom-style>

    <div class="image-info" hidden$="[[loading]]">
      <template is="dom-if" if="[[!data.item]]">
        <span>Clipboard Data<iron-icon style="--iron-icon-height:15px" icon="help"></iron-icon>
          <paper-tooltip>
            Editing clipboard data is not associated with an item until
            pasting into an item triggers the server syncing.
            Until then all the modifications have hitherto been kept
            locally within the clipboard.
          </paper-tooltip>
        <span><br>
      </template>
      <template is="dom-if" if="[[data.name]]"> Name: [[data.name]] <br> </template>
      Width: [[imageWidth]]<br>
      Height: [[imageHeight]]<br>
    </div>
    <paper-icon-button class="close-button" icon="cancel" on-tap="_deactivate">
    </paper-icon-button>

    <template is="dom-if" if="[[loading]]">
      <img style="position:absolute" width="200px" height="200px" src="/images/logo-pumpkin-bouncing.svg">
    </template>

    <svg
       xmlns:svg="http://www.w3.org/2000/svg"
       xmlns="http://www.w3.org/2000/svg"
       xmlns:xlink="http://www.w3.org/1999/xlink"
       id="canvas"
       version="1.1"
       viewBox="0 0 200 200"
       preserveAspectRatio="none"
       width="0"
       height="0"
       overflow="visible"
       hidden$="[[loading]]">

       <defs>
         <path id="chevrons" d="M -2.6,4.6 -7.2,0 -2.6,-4.6 -4,-6 -10,0 -4,6 Z M 2.6,4.6 7.2,0 2.6,-4.6 4,-6 10,0 4,6 Z" style$="[[_styleArrow(tracking)]]"/>
       </defs>

       <path d$="[[rPath]]" fill="rgba(0,0,0,0.9)" stroke="none"/>

       <use xlink:href="#chevrons" transform$="[[_translateArrows(scaleFactor,imageWidth,imageHeight,dataMidW,dataTop,90)]]" />
       <use xlink:href="#chevrons" transform$="[[_translateArrows(scaleFactor,imageWidth,imageHeight,dataLeft,dataMidH)]]" />
       <use xlink:href="#chevrons" transform$="[[_translateArrows(scaleFactor,imageWidth,imageHeight,dataMidW,dataBottom,90)]]" />
       <use xlink:href="#chevrons" transform$="[[_translateArrows(scaleFactor,imageWidth,imageHeight,dataRight,dataMidH)]]" />

    </svg>

  </template>
  <script>
    class MGImageEditor extends Polymer.GestureEventListeners(
      Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element)
    ) {
      static get is() { return 'mg-image-editor'; }

      static get properties() { return {
        data: {
          type: Object,
          notify: true,
          observer: '_dataChanged',
        },

        rep: {
          type: String,
          notify: true,
          observer: '_repChanged',
        },

        src: {
          type: String,
          observer: '_srcChanged',
          value: null,
        },

        active: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
        },

        imageWidth: { type: Number, value: 0 },
        imageHeight: { type: Number, value: 0 },
        viewWidth: { type:Number, value: 0 },
        viewHeight: { type:Number, value: 0 },

        dataTop: {type:Number, value: 0},
        dataLeft: {type:Number, value: 0},
        dataWidth: {type:Number, value: 1},
        dataHeight: {type:Number, value: 1},
        dataMidH: {type:Number, value: 0.5},
        dataMidW: {type:Number, value: 0.5},

        scaleFactor: { type: Number, value: 1 },
        rPath: {
          type: String,
          value: "M 0 0 v 0 h 0 v 0 Z",
        },

        loading: Boolean,

        tracking: {
          type: Object,
          value: null,
        },
      }}

      static get observers() { return [
        '_editorRectChanged(dataLeft, dataTop, dataWidth, dataHeight, imageWidth, imageHeight)',
        '_dataRectChanged(data.roi)',
      ]}

      _dataRectChanged(roi) {
        if (roi) {
          this.setProperties({
            dataLeft: roi[0],
            dataTop: roi[1],
            dataWidth: roi[2],
            dataHeight: roi[3],
          });
        }
      }

      _editorRectChanged(l,t,w,h,iw,ih) {
        if (!this.data) {
          return;
        }

        this.setProperties({
          dataRight: l + w,
          dataBottom: t + h,
          dataMidW: l + w/2,
          dataMidH: t + h/2,
          rPath: `M 0 0 v ${ih} h ${iw} v -${ih} Z M ${l*iw} ${t*ih} h ${w*iw} v ${h*ih} h -${w*iw} Z`,
        });

      }

      _styleArrow(tracking) {
        return tracking ? 'fill:none;stroke:none' : 'fill:white;stroke-width:1;stroke:black';
      }

      _translateArrows(s,w,h,x,y,r) {
        x = x || 0;
        y = y || 0;
        r = r || 0;

        let ret = `translate(${x*w},${y*h})`;
        if (r) ret += ` rotate(${r})`;
        ret+= ` scale(${1.2*s})`;

        return ret;
      }

      connectedCallback(){
        super.connectedCallback();
        this.addEventListener('iron-resize', e => {
          this._setImageWH( this.imageWidth, this.imageHeight );
        },true);
        Polymer.Gestures.addListener(this, 'track', e => this._onTrack(e));
      }

      _setImageWH(w,h) {
        if (!w || !h) return;

        let vw = this.clientWidth - 60;
        let vh = this.clientHeight - 120;

        if (vw < 0 || vh < 0) return;

        if (w/h > vw/vh) {
          vh = vw * h/w;
        } else {
          vw = vh * w/h;
        }

        this.setProperties({
          scaleFactor:  w/vw,
          viewWidth: vw,
          viewHeight: vh,
          imageWidth: w,
          imageHeight: h,
          _EW: 40/vw,
          _EH: 40/vh,
        });

        this.$.canvas.setAttribute('width', vw);
        this.$.canvas.setAttribute('height', vh);
        this.$.canvas.setAttribute('viewBox',`0 0 ${w} ${h}`);

        this.set('canvasBB', this.$.canvas.getBoundingClientRect());

      }

      _onTrack(e) {
        if (!this.canvasBB) return;

        /* It will store 0..1 in database */
        let ax = (e.detail.x - this.canvasBB.left) / this.viewWidth;
        let ay = (e.detail.y - this.canvasBB.top) / this.viewHeight;
        let ew = this._EW;
        let eh = this._EH;
        let ddx = e.detail.ddx / this.viewWidth;
        let ddy = e.detail.ddy / this.viewHeight;

        switch (e.detail.state) {
          case 'start':
            this.tracking = {l: 0, t: 0, w: 0, h: 0};

            if (ax >= this.dataLeft + ew && ax < this.dataRight - ew
              && ay >= this.dataTop + eh && ay < this.dataBottom - eh) {
              this.tracking.l = 1;
              this.tracking.t = 1;
            } else {
              if (ax < this.dataLeft + ew) {
                this.tracking.l = 1;
                this.tracking.w = -1;
              } else if (ax >= this.dataRight - ew) {
                this.tracking.w = 1;
              }

              if (ay < this.dataTop + eh) {
                this.tracking.t = 1;
                this.tracking.h = -1;
              } else if (ay >= this.dataBottom - eh) {
                this.tracking.h = 1;
              }
            }

            break;
          case 'end':
            this.set('tracking', null);
            this.set('data.roi',[this.dataLeft,this.dataTop,this.dataWidth,this.dataHeight]);
            break;
          case 'track': {

            /* XXXX hack to clear selection */
            if ( document.selection ) {
              document.selection.empty();
            } else if ( window.getSelection ) {
              window.getSelection().removeAllRanges();
            }

            if (this.tracking.l) {
              let l = this.dataLeft + ddx;
              this.set('dataLeft',l > 1 ? 1 : l);
            }
            if (this.tracking.t) {
              let t = this.dataTop + ddy;
              this.set('dataTop', t > 1 ? 1 : t);
            }
            if (this.tracking.w) {
              let w = this.dataWidth + ddx * this.tracking.w;
              this.set('dataWidth', w < 0 ? 0 : w);
            }
            if (this.tracking.h) {
              let h = this.dataHeight + ddy * this.tracking.h;
              this.set('dataHeight', h < 0 ? 0 : h);
            }

            if (this.dataLeft < 0) {
              let w = this.dataWidth + this.dataLeft;
              this.set('dataWidth', w < 0 ? 0 : w);
              this.set('dataLeft', 0);
            } else if (this.dataLeft + this.dataWidth > 1) {
              let w = 1 - this.dataLeft;
              this.set('dataWidth', w < 0 ? 0 : w);
            }

            if (this.dataTop < 0) {
              let h = this.dataHeight + this.dataTop;
              this.set('dataHeight', h < 0 ? 0 : h);
              this.set('dataTop', 0);
            } else if (this.dataTop + this.dataHeight > 1) {
              let h = 1 - this.dataTop;
              this.set('dataHeight', h < 0 ? 0 : h);
            }

          } break;
        }
      }

      _onImageLoaded(e) {
        this.set('loading', false);
        this._setImageWH(e.path[0].width,e.path[0].height);
        this.set('src',e.path[0].src);
      }

      _dataChanged(data) {
        if (data) {
          this.setProperties({
            rep: data.rep,
            'dataLeft': data.roi[0],
            'dataTop': data.roi[1],
            'dataWidth': data.roi[2],
            'dataHeight': data.roi[3],
          });
        } else {
          this.set('rep', null);
        }
      }

      _repChanged(rep) {
        if (rep) {
          this.set('active',true);
          this.style.opacity = 1;
          this.set('loading', true);
          MGAPP.registerRepresentation(rep, (key,ev,val) => {
            if (key == this.rep) {
               let img = new Image();
               img.onload = e => this._onImageLoaded(e);
               img.src = val;
            }
          });
        } else {
          this.set('src',null);
          this.set('active',false);

          this.$.canvas.setAttribute('viewBox','0 0 200 200');
          this.$.canvas.setAttribute('width', 200);
          this.$.canvas.setAttribute('height', 200);
        }
      }

      _srcChanged(src) {
        this.$.canvas.style.backgroundImage = `url(${src})`;
      }


      _test(e) {
        console.log(e);
      }

      _deactivate(e) {
        this.style.opacity = 0;
        Polymer.Async.timeOut.run(() => {
          this.set('data',null);
        }, 500);
      }

    }

    customElements.define(MGImageEditor.is, MGImageEditor);
  </script>
</dom-module>
