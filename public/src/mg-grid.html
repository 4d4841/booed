<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../bower_components/iron-scroll-threshold/iron-scroll-threshold.html">
<link rel="import" href="../bower_components/iron-list/iron-list.html">
<link rel="import" href="../bower_components/paper-card/paper-card.html">

<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-image.html">

<dom-module id="mg-grid">
  <template>
      <custom-style>
    <style include="iron-flex iron-flex-alignment">
      :host {
        display: block;
        position: relative;
        @apply --layout-vertical;
        padding: 0;
        margin: 0;
      }

      iron-list {
      }

      #grid {
      }

      .grid-image {
        display: block;
        position: absolute;
        --mg-image: {
          box-sizing: border-box;
          border-radius: 5px;
        };
      }

    </style>
      </custom-style>

      <!-- TODO Use iron-list with a line height equals to the max height of highest item (to prevent being pulled out as an off-screen list entry) -->
      <dom-repeat
        id="grid"
        items="[[gridItems]]"
        mutable-data>
    <template strip-whitespace>
      <!--
    <iron-image sizing="cover" style$="[[_computeItemStyle(item,unitWidth,index)]]" class="grid-image" src="[[item.photo]]"></iron-image>
      -->
      <!--
    <paper-card image="[[item.photo]]" style$="[[_computePaperCardItemStyle(item,unitWidth,index,4)]]">
    </paper-card>
      -->
      <dom-if if="[[_itemInOffsetRange(item)]]">
    <template>
      <mg-image class="grid-image" src="[[item.photo]]" style$="[[_computeItemStyle(item,unitWidth,index,2)]]"></mg-image>
    </template>
      </dom-if>

    </template>
      </dom-repeat>

    <iron-scroll-threshold
      style="display:none"
      id="scrollThreshold"
      scroll-target="document"
      lower-threshold="500"
      lower-triggered="{{lowerTriggered}}"
      on-lower-threshold="_load">
    </iron-scroll-threshold>

  </template>
  <script>

    class MGGrid extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
      static get is() { return 'mg-grid'; }

      static get properties() { return {
        unitWidth: {
          type: Number,
        },

        gridItems: {
          type: Array,
          value: [],
        },

        /* This is for marking the last tested row (for each type of item)
           to avoid testing from the top rows. */
        sizeMap: {
          type: Object,
          value: {}
        },

        /* 2D-Array of boolens,once first rows are all-true
        then they will be shifted out then ++offset */
        collisionMap: {
          type: Array,
          value: []
        },

        /* marking top rows that are continuously filled */
        collisionOffset: {
          type: Number,
          value: 0
        },

        numberOfColumns: {
          type: Number,
          value: 6,
          observer: '_numberOfColumnsChanged'
        },

      }}

      static get observers() { return [
      ]}

      connectedCallback() {
        super.connectedCallback();
        this.addEventListener('iron-resize', this._onResizeEvent);

        this.__photoIndex = getRandomInt(0,1000);
        this._load();
      }

      disconnectedCallback() {
        this.removeEventListener('iron-resize', this._onResizeEvent);
        super.disconnectedCallback();
      }

      _load(what) {

        if (this.collisionMap.length+this.collisionOffset > 3000) return;

        if (this._loading) this._loading.cancel();
        this._loading = Polymer.Debouncer.debounce(this._loading,
                  Polymer.Async.timeOut.after(100),
                  this._loadSome.bind(this,10));
      }

      _getPhotoIndex() {
        this.__photoIndex+=getRandomInt(1,3);
        return 1+this.__photoIndex%100;
      }

      _loadSome(rows) {
        let originalOffset = this.collisionOffset;
        let u = this.unitWidth*0.75;
        while (this.collisionOffset < originalOffset + rows) {

          for (let j = 0; j < 5; j++) {

            let w = getRandomInt(1,3);
            let h = getRandomInt(1,3);

            this._appendItem({
              x: 0,
              y: 0,
              w: w,
              h: h,
              photo: "/moon-images/moon-"+this._getPhotoIndex()+".jpg",
              //photo: "https://unsplash.it/"+(w*u)+"/"+(h*u)+"/?random="+this.__photoIndex++,

            });
          }

          let w = getRandomInt(2,7);
          let h = getRandomInt(2,7);
          this._appendItem({
            x: 0,
            y: 0,
            w: w,
            h: h,
              photo: "/moon-images/moon-"+this._getPhotoIndex()+".jpg",
              //photo: "https://unsplash.it/"+(w*u)+"/"+(h*u)+"/?random="+this.__photoIndex++,
          });

        }
        this.$.scrollThreshold.clearTriggers();
      }

      _numberOfColumnsChanged(newNumColumns) {
        if (newNumColumns == this.numberOfColumns) return;
        this.sizeMap = {};
        this.collisionMap = [];
        this.collisionOffset = 0;
        this.gridItems = [];
        this.$.grid.items = [];
      }

      _testCollision(row,col) {
        if (row < this.collisionOffset) {
          return true;
        }
        return this.collisionMap[row-this.collisionOffset][col];
      }

      _itemInOffsetRange(item) {
        if (item.y <= this.collisionOffset+1) return true;
        return false;
      }

      _appendItem(anItem, rtl) {
        rtl = rtl ? true : false;

        let ew = anItem.width ? Math.ceil(anItem.width * this.numberOfColumns) : anItem.w;
        let eh = anItem.height ? Math.ceil(anItem.height * this.numberOfColumns) : anItem.h;

        anItem.w = ew;
        anItem.h = eh;

        if (ew > this.numberOfColumns) {
          console.log(anItem, "is too wide").
          return;
        }

        this.sizeMap[eh] = this.sizeMap[eh] || {[ew]:0};
        this.sizeMap[eh][ew] = this.sizeMap[eh][ew] || 0;

        let pN = this.sizeMap[eh][ew];
        let pS = pN + eh - 1;
        let pE = (rtl ? this.numberOfColumns : ew) - 1;
        let pW = rtl ? pE - ew + 1 : 0;

        seeking:
        while (true) {
          while (pE < this.numberOfColumns && pW >= 0) {

            while ((this.collisionMap.length+this.collisionOffset) <= pS) {
              let r = [];
              while (r.length < this.numberOfColumns) r.push(false);
              this.collisionMap.push(r);
            }

            let hasCollision = false;
            test_collision:

            for (let ri = pN; ri <= pS; ++ri) {
            for (let ci = pW; ci <= pE; ++ci) {
              if (this._testCollision(ri,ci)) {
                hasCollision = true;
                break test_collision;
              }
            }
            }

            if (!hasCollision) {
              this.sizeMap[eh][ew] = pN;
              anItem.x = pW;
              anItem.y = pN;

              /* Fill collision map */
              for (let ri = pN; ri <= pS; ++ri) {
              for (let ci = pW; ci <= pE; ++ci) {
                this.collisionMap[ri-this.collisionOffset][ci] = true;
              }
              }

              let firstRowFilled;
              do {
                firstRowFilled = true;
                for (let ci = this.numberOfColumns-1; ci >= 0; --ci) {
                  if (!this.collisionMap[0][ci]) {
                    firstRowFilled = false;
                    break;
                  }
                }
                if (firstRowFilled) {
                  this.collisionOffset++;
                  this.collisionMap.shift();
                }
              } while (firstRowFilled && this.collisionMap.length);

              break seeking;
            }

            pW += rtl ? -1 : 1;
            pE += rtl ? -1 : 1;
          }

          pE = (rtl ? this.numberOfColumns : ew) - 1;
          pW = rtl ? pE - ew + 1 : 0;
          ++pN;
          ++pS;
        }

        this.push('gridItems',anItem);
        this.style.height = (this.collisionOffset*this.unitWidth)+"px";
        //this.style.height = ((this.collisionMap.length+this.collisionOffset)*this.unitWidth)+"px";
        //this.$.grid.push('items', anItem);
        //this.$.griditems.push(anItem);
      }


      _onResizeEvent(e) {
          this.unitWidth = this.offsetWidth/this.numberOfColumns;
          /*
          let maxH = 1,
              maxW = 1;
          for (let i = 0, it; it = this.gridItems[i]; ++i) {
            let mh = it.y + it.h;
            if (mh > maxH) maxH = mh;
            let mw = it.x + it.w;
            if (mw > maxW) maxW = mw;
          }
          this.style.height = (maxH * this.unitWidth)+"px";
          this.style.width = (maxW * this.unitWidth)+"px";
          */
      }

      _computePaperCardItemStyle(item, blockSize, index, inset) {
        return this._computeItemStyle(item, blockSize, index, inset);
      }

      _computeItemStyle(item, blockSize, index, inset) {
        if (!inset) inset = 0;
        if (!blockSize) blockSize = this.offsetWidth/this.numberOfColumns;
        let unit = "px";
        let x = item.x;
        let y = item.y;
        let ret = "";
        ret += ";width: "+ Math.floor(blockSize * item.w - inset * 2) + unit;
        ret += ";height: "+ Math.floor(blockSize * item.h - inset * 2) + unit;
        ret += ";left: "+ Math.floor(blockSize * x + inset) + unit;
        ret += ";top: "+ Math.floor(blockSize * y + inset) + unit;
        return ret;
      }

    }

    customElements.define(MGGrid.is, MGGrid);
  </script>
</dom-module>
