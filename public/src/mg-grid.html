<link rel="import" href="../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../bower_components/iron-scroll-threshold/iron-scroll-threshold.html">
<link rel="import" href="../bower_components/iron-list/iron-list.html">
<link rel="import" href="../bower_components/paper-card/paper-card.html">

<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-image.html">

<dom-module id="mg-grid">
  <template>
      <custom-style>
    <style include="iron-flex iron-flex-alignment">
      :host {
        display: block;
        position: relative;
        @apply --layout-vertical;
        padding: 0;
        margin: 0;
        /*
        border: 1px solid red;
        */
      }

      /*
      .grid-image {
        position: absolute;
        overflow: hidden;
        box-sizing: border-box;
        border: 4px solid transparent;
        border-radius: 10px;
      }
      */

      iron-list {
      }

      #grid {
      }

      .grid-image {
        display: block;
        position: absolute;
        --mg-image: {
          box-sizing: border-box;
          border-radius: 5px;
        };
      }

      /*
      paper-card {
        border-radius: 5px;
        overflow: hidden;
      }
      */

    </style>
      </custom-style>

      <!-- TODO Use iron-list with a line height equals to the max height of highest item (too prevent being pulled out as an off-screen list entry) -->
      <dom-repeat
        id="grid"
        items="[[gridItems]]"
        mutable-data>
    <template strip-whitespace>
      <!--
    <iron-image sizing="cover" style$="[[_computeItemStyle(item,unitWidth,index)]]" class="grid-image" src="[[item.photo]]"></iron-image>
      -->
      <!--
    <paper-card image="[[item.photo]]" style$="[[_computePaperCardItemStyle(item,unitWidth,index,4)]]">
    </paper-card>
      -->
      <dom-if if="[[_itemInOffsetRange(item)]]">
    <template>
      <mg-image class="grid-image" src="[[item.photo]]" style$="[[_computeItemStyle(item,unitWidth,index,2)]]"></mg-image>
    </template>
      </dom-if>

    </template>
      </dom-repeat>

    <iron-scroll-threshold
      style="display:none"
      id="scrollThreshold"
      scroll-target="document"
      lower-threshold="500"
      lower-triggered="{{lowerTriggered}}"
      on-lower-threshold="_load">
    </iron-scroll-threshold>

  </template>
  <script>

    class MGGrid extends Polymer.mixinBehaviors([Polymer.IronResizableBehavior], Polymer.Element) {
      static get is() { return 'mg-grid'; }

      static get properties() { return {
        unitWidth: {
          type: Number,
        },

        gridItems: {
          type: Array,
          value: [],
        },

        sizeMap: {
          type: Object,
          value: {}
        },

        /* 2D-Array of boolens,once first rows are all-true
        then they will be shifted out then ++offset */
        collisionMap: {
          type: Array,
          value: []
        },
        collisionOffset: {
          type: Number,
          value: 0
        },

        numberOfColumns: {
          type: Number,
          value: 6,
          observer: '_numberOfColumnsChanged'
        },

      }}

      _numberOfColumnsChanged(newNumColumns) {
        if (newNumColumns == this.numberOfColumns) return;
        this.sizeMap = {};
        this.collisionMap = [];
        this.collisionOffset = 0;
        this.gridItems = [];
        this.$.grid.items = [];
      }

      /* row and col starts at 1 1 */
      _testCollision(row,col) {
        if (row <= this.collisionOffset) {
          return true;
        }
        return this.collisionMap[row-1-this.collisionOffset][col-1];
      }

      _itemInOffsetRange(item) {
        if (item.y <= this.collisionOffset+1) return true;
        return false;
      }

      _appendItem(anItem, rtl) {
        rtl = rtl ? true : false;

        let ew = anItem.width ? Math.ceil(anItem.width * this.numberOfColumns) : anItem.w;
        let eh = anItem.height ? Math.ceil(anItem.height * this.numberOfColumns) : anItem.h;
        let sizeMapKey = ew+','+eh;

        anItem.w = ew;
        anItem.h = eh;

        if (ew > this.numberOfColumns) {
          console.log(anItem, "is too wide").
          return;
        }

        if (! this.sizeMap[sizeMapKey]) {
          this.sizeMap[sizeMapKey] = 1;
        }

        let py1 = this.sizeMap[sizeMapKey];
        let py2 = py1 + eh - 1;
        let px2 = rtl ? this.numberOfColumns : ew;
        let px1 = rtl ? px2 - ew + 1 : 1;

        seeking:
        while (true) {
          while (px2 <= this.numberOfColumns && px1 >= 1) {

            while ((this.collisionMap.length+this.collisionOffset) < py2) {
              let r = [];
              while (r.length < this.numberOfColumns) r.push(false);
              this.collisionMap.push(r);
            }

            let hasCollision = false;
            test_collision:

            for (let ri = py1; ri <= py2; ++ri) {
            for (let ci = px1; ci <= px2; ++ci) {
              if (this._testCollision(ri,ci)) {
                hasCollision = true;
                break test_collision;
              }
            }
            }

            if (!hasCollision) {
              this.sizeMap[sizeMapKey] = py1;
              anItem.x = px1;
              anItem.y = py1;

              /* Fill collision map */
              for (let ri = py1; ri <= py2; ++ri) {
              for (let ci = px1; ci <= px2; ++ci) {
                this.collisionMap[ri-1-this.collisionOffset][ci-1] = true;
              }
              }

              let firstRowFilled;
              do {
                firstRowFilled = true;
                for (let ci = this.numberOfColumns-1; ci >= 0; --ci) {
                  if (!this.collisionMap[0][ci]) {
                    firstRowFilled = false;
                    break;
                  }
                }
                if (firstRowFilled) {
                  this.collisionOffset++;
                  this.collisionMap.shift();
                }
              } while (firstRowFilled && this.collisionMap.length);

              break seeking;
            }

            if (rtl) {
              --px1;
              --px2;
            } else {
              ++px1;
              ++px2;
            }
          }

          px2 = rtl ? this.numberOfColumns : ew;
          px1 = rtl ? px2 - ew + 1 : 1;
          ++py1;
          ++py2;
        }

        this.push('gridItems',anItem);
        this.style.height = (this.collisionOffset*this.unitWidth)+"px";
        //this.style.height = ((this.collisionMap.length+this.collisionOffset)*this.unitWidth)+"px";
        //this.$.grid.push('items', anItem);
        //this.$.griditems.push(anItem);
      }

      static get observers() { return [
      ]}

      connectedCallback() {
        super.connectedCallback();
        this.addEventListener('iron-resize', this._onResizeEvent);

        this.__photoIndex = 0;
        this._load();
      }

      _load(what) {

        if (this.collisionMap.length+this.collisionOffset > 3000) return;

        if (this._loading) this._loading.cancel();
        this._loading = Polymer.Debouncer.debounce(this._loading,
                  Polymer.Async.timeOut.after(100),
                  this._loadSome.bind(this,10));
      }

      _getPhotoIndex() {
        this.__photoIndex++;
        return 1+this.__photoIndex%10;
        /*
        this.__photoIndex+=getRandomInt(1,5);
        return 1+this.__photoIndex%102;
        */
      }

      _loadSome(rows) {
        let originalOffset = this.collisionOffset;
        while (this.collisionOffset < originalOffset + rows) {

          for (let j = 0; j < 5; j++) {

            let w = getRandomInt(1,3);
            let h = getRandomInt(1,3);

            this._appendItem({
              x: 0,
              y: 0,
              w: w,
              h: h,
              photo: "https://lorempixel.com/"+(w*100)+"/"+(h*100)+"/cats/"+this._getPhotoIndex(),

            });
          }

          let w = getRandomInt(2,7);
          let h = getRandomInt(2,7);
          this._appendItem({
            x: 0,
            y: 0,
            w: w,
            h: h,
              photo: "https://lorempixel.com/"+(w*100)+"/"+(h*100)+"/cats/"+this._getPhotoIndex(),
          });

        }
        this.$.scrollThreshold.clearTriggers();
      }

      disconnectedCallback() {
        this.removeEventListener('iron-resize', this._onResizeEvent);
        super.disconnectedCallback();
      }

      _onResizeEvent(e) {
          this.unitWidth = this.offsetWidth/this.numberOfColumns;
          let maxH = 1,
              maxW = 1;
          for (let i = 0, it; it = this.gridItems[i]; ++i) {
            let mh = it.y + it.h - 1;
            if (mh > maxH) maxH = mh;
            let mw = it.x + it.w - 1;
            if (mw > maxW) maxW = mw;
          }
//          this.style.height = (maxH * this.unitWidth)+"px";
//          this.style.width = (maxW * this.unitWidth)+"px";
      }

      _computePaperCardItemStyle(item, blockSize, index, inset) {
        return this._computeItemStyle(item, blockSize, index, inset);
      }

      _computeItemStyle(item, blockSize, index, inset) {
        if (!inset) inset = 0;
        if (!blockSize) blockSize = this.offsetWidth/this.numberOfColumns;
        let unit = "px";
        let x = item.x - 1;
        let y = item.y - 1;
        let ret = "";
        ret += ";width: "+ Math.floor(blockSize * item.w - inset * 2) + unit;
        ret += ";height: "+ Math.floor(blockSize * item.h - inset * 2) + unit;
        ret += ";left: "+ Math.floor(blockSize * x + inset) + unit;
        ret += ";top: "+ Math.floor(blockSize * y + inset) + unit;
        return ret;
      }

    }

    customElements.define(MGGrid.is, MGGrid);
  </script>
</dom-module>
