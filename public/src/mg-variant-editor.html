<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../bower_components/paper-styles/element-styles/paper-material-styles.html">
<link rel="import" href="../bower_components/paper-item/paper-icon-item.html">
<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-variant-cell.html">
<link rel="import" href="mg-input.html">

    <dom-module id="mg-variant-editor">
  <template strip-whitespace>
<style include="paper-material-styles mg-common-styles iron-flex iron-flex-alignment">
:host {
  /*border: 2px solid tomato;*/
  width: auto;
  height: auto;
  @apply --layout-horizontal;
  @apply --layout-start-justified;
  box-sizing: content-box;
}

#variant-selector {
  max-height: 20vh;
  overflow-y: auto;
}

#variants-container {
  padding: 5px;
  margin: 5px;
  border-radius: 5px;
}

#value-container {
  @apply --paper-font-caption;
}

#value-container iron-icon {
  --iron-icon-height: 14px;
}

#type-name {
  width: 95px;
  margin-right: 10px;
}

#type-custom {
  width: 95px;
}

.visibility-button:active {
  color: tomato;
}

</style>

  <div class="vertical layout">
<div id="variants-container" class="paper-material vertical layout start-justified" elevation="1">
  <!-- Editor title -->
      <div id="value-container" class="horizontal layout center">
    <template is="dom-if" if="{{opened}}">
  <template is="dom-if" if="{{variant.value}}">
    [[variant.value]]
    <template is="dom-if" if="{{variant.variants}}">
      <iron-icon icon="chevron-right"></iron-icon>
      [[variant.type]]
    </template>
  </template>
  <div class="flex"></div>
    </template>
    <iron-icon class="visibility-button" on-click="_onToggleOpened" icon="{{_formatIconOpened(opened)}}"></iron-icon>
      </div>

  <template is="dom-if" if="{{opened}}">

    <!-- Type Selector -->
    <template is="dom-if" if="{{subvariantList.length}}">
  <div class="horizontal layout">
    <paper-dropdown-menu
      id="type-name"
      label="ตัวเลือก"
    > <paper-listbox
        attr-for-selected="name"
        slot="dropdown-content"
        class="dropdown-content layout start"
        selected="{{selectedTypeDef.name}}"
      > <template is="dom-repeat" items="[[menu.entries]]">
          <paper-icon-item label="[[item.title]]" name="[[item.name]]">
            <iron-icon icon="[[item.icon]]" slot="item-icon"></iron-icon>
            [[item.title]]
          </paper-icon-item>
        </template>
      </paper-listbox>
    </paper-dropdown-menu>

    <template is="dom-if" if="[[testEqual(selectedTypeDef.name,'custom')]]">

      <mg-input
        label="ชื่อ"
        value="{{selectedTypeDef.custom}}"
        min-width="70"
      > <iron-icon icon="editor:mode-edit" slot="prefix"></iron-icon>
      </mg-input>

    </template>

      <template is="dom-if" if="[[testEqual(selectedTypeDef.name,'price')]]">
    <paper-dropdown-menu
      id="type-custom"
      label="สกุลเงิน"
    > <paper-listbox
        slot="dropdown-content"
        class="dropdown-content"
        attr-for-selected="currency"
        selected="{{selectedTypeDef.custom}}"
      > <paper-icon-item label="บาท" currency="thb">
      <iron-icon icon="booed:attach-money-thb" slot="item-icon"></iron-icon> บาท
        </paper-icon-item>
        <paper-icon-item label="เยน" currency="jpy">
      <iron-icon icon="booed:attach-money-jpy" slot="item-icon"></iron-icon> เยน
        </paper-icon-item>
        <paper-icon-item label="วอน" currency="krw">
      <iron-icon icon="booed:attach-money-krw" slot="item-icon"></iron-icon> วอน
        </paper-icon-item>
        <paper-icon-item label="ยูเอสดอลล่าร์" currency="usd">
      <iron-icon icon="editor:attach-money" slot="item-icon"></iron-icon> ยูเอสดอลล่าร์
        </paper-icon-item>
      </paper-listbox>
    </paper-dropdown-menu>
      </template>

  </div>
    </template>
    <!-- End: Type Selector -->

  <!-- Children List -->
  <iron-selector
    id="variant-selector"
    attr-for-selected="name"
    selected-attribute="selected"
    selected="{{selectedKey}}"
    > <template is="dom-repeat" items="{{subvariantList}}" as="subvariant">
      <!--XXX remove name here-->
    <mg-variant-cell
      name="[[subvariant.key$]]"
      variant-type="[[_computeType(selectedTypeDef.name,selectedTypeDef.custom)]]"
      variant="{{subvariant}}"
    ></mg-variant-cell>
      </template>
  </iron-selector>

  <!-- Comment -->
    <template is="dom-if" if="{{_hasComment(variant.comment)}}">
  <mg-input
    label="คอมเม้นท์"
    value="{{variant.comment}}"
    min-width="150"
  > <iron-icon icon="editor:mode-edit" slot="prefix"></iron-icon>
  </mg-input>
    </template>

  <!-- Foot Buttons -->
  <div class="horizontal layout center-justified">
<paper-icon-button
  icon="add"
  on-click="_onAddVariant"
></paper-icon-button>
<paper-icon-button
  icon="remove"
  on-click="_onRemoveVariant"
  disabled="[[!selectedKey]]"
></paper-icon-button>
<paper-icon-button
  icon="booed:duplicate-selection"
  on-click="_onDuplicateSelection"
  disabled="[[!selectedKey]]"
></paper-icon-button>
<paper-icon-button
  icon="{{_formatIconComment(variant.comment)}}"
  on-click="_onToggleComment"
></paper-icon-button>
  </div>

  </template>
</div>
  </div>

  <!-- Child editor -->
  <template is="dom-if" if="[[selectedSubvariant]]">
<mg-variant-editor
  menu="[[menu]]"
  variant="{{selectedSubvariant}}"
  depth="[[_deeper(depth)]]"
></mg-variant-editor>
  </template>

  </template>
  <script>
class MGVariantsEditor extends Polymer.Element {
  static get is() { return 'mg-variant-editor'; }

  static get properties() { return {
    /* Map for caching index, uncomment this when __dataLinkedPaths can no longer be abused.
    variantsDataMap: {
      type: Object,
      value: function(){return new WeakMap()},
    },
    */

    variant: {
      type: Object,
      notify: true,
    },

    /* Paths-linking note: The element maintain 1:1 linkPaths from
     * variant.variants (object) <= subvariantList (array) and
     * subvariantList (current selected item) <= selectedSubvariant
     * to route all changes from nested children up the product-editor.
     */
    /* Splice-to-remove only */
    subvariantList: {
      type: Array,
      value: function(){return [];},
    },

    selectedTypeDef: {
      type: Object,
      value: function(){return {};},
    },
    menu: {
      type: Object,
      observer: '_menuChanged'
    },

    selectedSubvariant: {
      type: Object,
    },

    selectedVariants: {
      type: Array,
      value: function(){return {};},
    },

    selectedKey: {
      type: String,
      observer: '_selectedKeyChanged',
    },

    opened: {
      type: Boolean,
      value: true,
    },

    /* debugging */
    depth: {
      value: 0,
    },
  }}

  _deeper(depth) {
    return depth + 1;
  }

  static get observers() { return [
    '_selectedTypeDefChanged(selectedTypeDef.name,selectedTypeDef.custom)',
    '_variantDataListChanged(subvariantList.splices)',
    '_variantTypeChanged(variant.type)',
    '_subvariantsChanged(variant.variants.*)',
  ]}

  _computeType(name,custom) {
    if (name == 'color' || name =='size') {
      custom = '';
    }
    return name + (custom ? ':'+custom : '');
  }

  _variantTypeChanged(newType,oldType) {
    if (newType) {
      let nc = newType.split(':');
      this.set('selectedTypeDef', {name:nc[0], custom:nc[1]});
    }
  }

  _selectedTypeDefChanged(name,custom) {
    if (name == 'custom') {
      this.set('variant.type','custom:'+(custom||''));
    } else if (name == 'price') {
      this.set('variant.type','price:'+(custom||''));
    } else if (name) {
      this.set('variant.type',name);
    }
  }

  /* An EXPERIMENT to rely on linked paths defined within __dataLinkedPaths.
   * This is going to use it instead of using indexOf() or observed selected index.
   * If one day this will broken it may then switch back to the variantsDataMap version.
   */
  _selectedKeyChanged(key,oldKey) {
    if (oldKey) {
      //this.unlinkPaths('subvariantList.'+this.variantsDataMap.get(this.variant.variants[oldKey]));

      /* Unlink old selectedSubvariant -> subvariantList */
      this.unlinkPaths(this.__dataLinkedPaths['variant.variants.'+oldKey]);
    }

    this.set('selectedSubvariant',undefined);

    if (key) {
      this.set('selectedSubvariant', this.variant.variants[key]);

      //this.linkPaths('subvariantList.'+this.variantsDataMap.get(this.variant.variants[key]), 'selectedSubvariant');

      /* Link selectedSubvariant to the indexed subvariantList entry pointing to the new current key */
      this.linkPaths(this.__dataLinkedPaths['variant.variants.'+key],'selectedSubvariant');
    }
  }

  _variantDataListChanged(splices) {
    if (splices) {
      splices.indexSplices.forEach(s => {
        s.removed.forEach(v => {
          //this.variantsDataMap.delete(v);

          if (v === this.selectedSubvariant) {
            console.assert(this.__dataLinkedPaths[this.__dataLinkedPaths['variant.variants.'+v.key$]] == 'selectedSubvariant', 'XXX');
            this.unlinkPaths(this.__dataLinkedPaths['variant.variants.'+v.key$]);
            this.set('selectedSubvariant', undefined);
          }

          this.unlinkPaths('variant.variants.'+v.key$);

        });
        /* Re-link all from the changed index */
        for(let i = s.index,so; so = s.object[i]; ++i) {
          //this.variantsDataMap.set(so,i);
          this.linkPaths('variant.variants.'+so.key$,'subvariantList.'+i);
          if (so === this.selectedSubvariant) {
            this.linkPaths('subvariantList.'+i,'selectedSubvariant');
          } else {
            /* Clear any possible selectedSubvariant's linked path */
            this.unlinkPaths('subvariantList.'+i);
          }
        }

      });
    }
  }

  _addVariantData(key,variant) {
    if (!variant || !key) {
      return;
    }

    if(!this.__dataLinkedPaths || !this.__dataLinkedPaths['variant.variants.'+key]) {
      variant.key$ = key;
      this.push('subvariantList', variant);
    }
  }

  _subvariantsChanged(change) {
    if (!change) {
      return;
    }

    /* change.path : 'variant.variants.${key}.selected$'
     *
     * "variant.variants" : 16
     * ${key} : 20
     * "selected$" : 9
     */

    switch(change.path.length) {
    case 16: {
      /* variant.variants */
      let nowKey = this.selectedKey;
      this.set('selectedKey',null);
      this.splice('subvariantList',0,this.subvariantList.length);
      if (change.value) {
        for (let key in change.value) {
          this._addVariantData(key, change.value[key]);
          if (key == nowKey) {
            this.set('selectedKey', nowKey);
          }
        }
      }
    } break;
    case 37: {
      /* variant.variants.${key} */
      if (change.value === null) {
        this.splice('subvariantList',this.__dataLinkedPaths[change.path].split('.').pop(),1);
      } else if (!this.__dataLinkedPaths || !this.__dataLinkedPaths[change.path]) {
        this._addVariantData(change.path.slice(-20), change.value);
      } else { /* XXX Wouldn't be here since all subvariants in the list were spliced out */
        let key = change.path.slice(-20);
        change.value.key$ = key;
        this.set(this.__dataLinkedPaths[change.path], change.value);
        if (key == this.selectedKey) {
          this.set('selectedSubvariant', change.value);
        }
      }
    } break;
    case 47: if (change.path.endsWith('.selected$')) {
      /* variant.variants.${key}.selected$ */
      /* Selected status set by cells */
      if (change.value) {
        this.set('selectedKey', change.path.slice(17,37));
      }
    }}
  }

  _onToggleOpened(e) {
    this.set('opened',!this.opened);
  }

  _formatIconOpened(opened) {
    return opened ? 'visibility' : 'visibility-off';
  }

  _formatIconComment(comment) {
    if (typeof comment === 'string') {
      return "booed:comment-disabled";
    } else {
      return "editor:mode-edit";
    }
  }

  _hasComment(comment) {
    return typeof comment === 'string' ? true : false;
  }

  _onToggleComment(e){
    if (typeof this.variant.comment === 'string') {
      this.set('variant.comment', null);
    } else {
      this.set('variant.comment', '');
    }
  }

  _onAddVariant(e){
    if (!this.variant) {
      this.set('variant',{type:'custom:'});
    }
    /* XXX should get key from a better path */
    let vkey = MHA.DB.ref().push().key;
    let variants = this.variant.variants;
    if (!variants) {
      this.set('variant.variants',{});
    }

    this.set(['variant.variants',vkey],{key$:vkey, type:'custom:'}); /* XXX custom: leaked into db even no use*/
    this.set('selectedKey',vkey);
    return vkey;
  }

  _onRemoveVariant(e) {
    let deletingKey = this.selectedKey;
    this.set('selectedKey',null);
    this.set('variant.variants.'+deletingKey, null);
    if (this.variant.variants && !Object.values(this.variant.variants).some(value => value)) {
      this.set('variant.variants', null);
    }
  }

  _onDuplicateSelection(e) {
    var newKey;
    function cloneFunc(path, value) {

      if (path.slice(-30).startsWith('.variants.')) {
        let replacingKey = MHA.DB.ref().push().key;
        let newpath = path.slice(0, path.length-20) + replacingKey;
        let newval = Object.assign({}, value, {key$: replacingKey});
        if (!newKey) newKey = replacingKey;
        return [newpath,newval,cloneFunc];
      }

      return;
    }
    MHA.Path.deepSet(this, 'variant.variants.< 20 chars new key >', this.variant.variants[this.selectedKey], cloneFunc);
  }

  testEqual(a,b) {
    if (a == b) return true;
    return false;
  }

  _menuChanged(newMenu,oldMenu) {
  }

}

customElements.define(MGVariantsEditor.is, MGVariantsEditor);
  </script>
    </dom-module>
