<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">

<dom-module id="mg-input">
<template strip-whitespace>
    <customstyle>
  <style>
  </style>
    </customstyle>

  <paper-input
    id="input"
    value={{value}}
    label="{{label}}"
    focused="{{focused}}"
    readonly="{{readonly}}"
    disabled="{{disabled}}"
    always-float-label="[[computedFloatLabel]]"
  > <template is="dom-if" if="[[icon]]">
      <iron-icon icon="[[icon]]" slot="prefix"></iron-icon>
    </template>
    <slot name="prefix" slot="prefix"></slot>
    <slot name="suffix" slot="suffix"></slot>
  </paper-input>
<!--
  <paper-input
    id="input"
    value={{value}}
    label="{{label}}"
    focused="{{inputFocused}}"
    always-float-label="[[inputFocused]]"
  ><template is="dom-if" is="[[icon]]"><iron-icon icon="[[icon]]" slot="prefix"></iron-icon></template>
  </paper-input>
-->

</template>
<script>
(function(){
let MeasureContext = null;

class MGInput extends Polymer.Element {
  static get is() { return 'mg-input'; }

  static get properties() { return {
    icon: String,
    label: String,
    value: {
      type: String,
      value: '',
      notify: true,
      observer: '_valueChanged',
    },
    computedFloatLabel: {
      type: Boolean,
      computed: '_computeFloatLabel(focused,alwaysFloatLabel)'
    },
    alwaysFloatLabel: {
      type: Boolean,
      notify: true,
    },
    focused: {
      type: Boolean,
      notify: true,
      value: false,
      /*observer: '_focusedChanged',*/
    },
    minWidth: {
      type: Number,
      value: 100,
      observer: 'minWidthChanged'
    },
  }}

  static get observers() { return [
  ]}

  _computeFloatLabel(focused,always) {
    if (typeof always === 'undefined') {
      return focused;
    }
    return always;
  }

  constructor() {
    super();

    if (!MeasureContext) {
       MeasureContext = document.createElement("canvas").getContext("2d");
       MeasureContext['font'] = "16px Roboto, Noto, sans-serif";
    }
  }

  /*
  _focusedChanged(focus) {
  }
  */

  focus() {
    this.$.input.focus();
  }

  connectedCallback() {
    super.connectedCallback();
    this.$.input.addEventListener('iron-input-ready',e => {
      this.$.input.inputElement.inputElement.style.width = this.minWidth+'px';
    });
  }

  _valueChanged(newValue, oldValue) {
    let width = MeasureContext.measureText(newValue).width + 10; /* Add an impression space */
    let elm = this.$.input.inputElement.inputElement;
    if (elm) {
      elm.style.width = (width < this.minWidth ? this.minWidth: width) + 'px';
    }
  }

  minWidthChanged(w) {
    this._valueChanged(this.value);
  }

}

customElements.define(MGInput.is, MGInput);
})();
</script>
</dom-module>
