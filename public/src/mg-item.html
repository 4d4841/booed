<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

/* XXX Make item behavior */
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-input.html">
<link rel="import" href="mg-item-image.html">


<dom-module id="mg-item">
  <template strip-whitespace>
      <custom-style>
    <style is="custom-style" include="mg-common-styles iron-flex iron-flex-alignment">
      :host {
      }

      .file-item {
        width: 100%;
        position: relative;
      }

      #selector {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        padding: 0px;
        height: 100%;
      }

      .image-icon {
        margin: 0 5px 5px 0;
        width: 120px;
        height: 120px;
      }

    </style>
      </custom-style>

    <iron-collapse class="vertical layout" opened="[[_shouldOpen(itemKey)]]">

      <div class="horizontal layout end">

        <template is="dom-if" if="{{loading}}">
          <img height="62px" src="images/logo-bounce.svg">
        </template>

        <template is="dom-if" if="{{!loading}}">

          <paper-input
            label="ชื่อแกลเลอรี่"
            focused="{{focusedName}}"
            always-float-label="[[focusedName]]"
            value="{{itemName}}"
          >
            <iron-icon icon="[[_iconForRole(itemRole)]]" slot="prefix"></iron-icon>
          </paper-input>

          <paper-button on-tap="_onAddButtonTap">
            <iron-icon icon="add"></iron-icon> เพิ่มรูป
          </paper-button>
          <template is="dom-if" if="{{hasSelection}}">
            <paper-button on-tap="_onDeleteButtonTap">
              <iron-icon icon="delete"></iron-icon> ลบ
            </paper-button>
            <paper-button on-tap="_onReorderButtonTap">
              <iron-icon icon="reorder"></iron-icon> เรียง
            </paper-button>
            <paper-button on-tap="_onAddButtonTap">
              <iron-icon icon="add-to-photos"></iron-icon> แกลเลอรี่
            </paper-button>
            <paper-button on-tap="_onCancelButtonTap">
              <iron-icon icon="cancel"></iron-icon> ยกเลิก
            </paper-button>
          </template>

        </template>

        <input type="file" id="fileInput" on-change="_filesSelected" hidden multiple>

      </div>

      <template is="dom-if" if="{{!photoList.0}}">
        <div class="vertical layout center center-justified" style="border-radius:5px;border:1px dashed tomato;width:100%;height:500px">
          แกลเลอรี่เปล่า ยังไม่มีรูป
        </div>
      </template>

      <iron-selector
        id="selector"
        attr-for-selected="key"
        selected-values="{{selectedImages}}"
        multi>

      <template is="dom-repeat" items="{{photoList}}" observe="order" sort="{{_reorderPhoto}}" mutable-data>

        <mg-item-image
          key="[[item.key]]"
          class="image-icon"
          src="[[item._src]]"
          progress="[[item._progress]]"
          label="[[item.name]]"
          selection-order="[[item._selectionOrder]]"
          icon="photo"
          transition="1.5s"
          spinner
          on-tap="_onItemTap"
        ></mg-item-image>

      </template>

      </iron-selector>

    </iron-collapse>

  </template>
  <script>
    class MGItem extends Polymer.Element {
      static get is() { return 'mg-item'; }

      static get properties() { return {
        files: Object,

        itemKey: {
          type: String,
          notify: true,
        },

        itemRole: {
          type: String,
        },

        itemName: {
          type: String,
          notify: true,
        },

        photoList: {
          type: Array,
          value: [],
        },

        selectedImages: {
          type: Array,
          notify: true,
        },

        hasSelection: Boolean,
      }}

      static get observers() { return [
        '_itemKeyChanged(me.user, itemKey)',
        '_itemNameChanged(me.user, itemRole, itemName)',
        '_selectedImagesChanged(selectedImages.splices)',
      ]}

      _reorderPhoto(a,b) {
        let ao = a.order || Number.MAX_SAFE_INTEGER;
        let bo = b.order || Number.MAX_SAFE_INTEGER;

        return ao-bo;
      }

      _selectedImagesChanged(changes) {
        if (changes) {
          let orderNumber = 0;
          /* Remove number from deselected photo */
          changes.indexSplices.forEach(splice => {
            splice.removed.forEach(removedKey => {
              this._setPhotoKeyProperty(removedKey,'_selectionOrder',null);
            })
          });

          this.selectedImages.forEach(key => {
            this._setPhotoKeyProperty(key,'_selectionOrder',++orderNumber);
          });
        }
        if (this.selectedImages.length) {
          this.set('hasSelection', true);
        } else {
          this.set('hasSelection', false);
        }

        /*
        if (this._InsertRange) {
          delete this._InsertRange;
          let beginKey = this.selectedImages.length ?
          let beginIndex,endIndex;
          for(let i = 0, photo; photo = this.photoList[i]; ++i) {
            if ()
          }
        }
        */
      }

      _onItemTap(e) {
        if (e.detail.sourceEvent.shiftKey) {
          if (typeof(this._LastTapIndex) == "undefined") {
            this._LastTapIndex = -1;
          }

          let inc = this._LastTapIndex < e.model.index ? 1 : -1;

          for (let i = this._LastTapIndex + inc; inc > 0 ? i < e.model.index : i > e.model.index; i+=inc) {
            this.$.selector.selectIndex(i);
          }
        }
        this._LastTapIndex = e.model.index;
      }

      _indexImage(imageKey) {
        /* XXX optimize later
        if (!this._ImageMap) {
          this._ImageMap = newMap();
        }

        let idx = this._ImageMap.get(imageKey);
        if (this.photoList.length > idx &&  this.photoList[idx].key == imageKey) {
          return idx;
        }
        */

        for (let i = 0, data; data = this.photoList[i]; ++i) {
          //this._ImageMap.set(data.key, i);
          if (data.key == imageKey) {
            return i;
          }
        }
        return -1;
      }

      _setPhotoKeyProperty(key,prop,val) {
        let idx = this._indexImage(key);
        if (idx !== -1) {
          if (this.photoList[idx][prop] != val) {
            this.photoList[idx][prop] = val;
            this.notifyPath(['photoList',idx,prop]);
          }
        }
      }

      _setPhotoThumbnail(thumbnailKey,val) {
        for (let i = 0, photo; photo = this.photoList[i]; ++i) {
          if (photo.thumbnail == thumbnailKey) {
            if (this.photoList[i]._src != val) {
              this.photoList[i]._src = val;
              this.notifyPath(['photoList',i,'_src']);
            }
          }
        }
      }

      _uploadReps(uid,itemKey,files) {
        let storageRef = MGAPP.ST.ref('home').child(uid).child('representations');

        Array.from(files).forEach(function(imgFile){
          let repKey = MGAPP.DB.ref('representations').push().key;
          let thumbKey = MGAPP.DB.ref('representations').push().key;
          let imgKey =  MGAPP.DB.ref('home').child(uid).child(itemKey).child('images').push().key;
          let imgName = imgFile.name.split('.')[0];

          /* An item image would contain link(s) to storage image representation. */
          let image = {
            key: imgKey,
            thumbnail: repKey, /* db representations/repKey contains storage info eg. uid */
            name: imgName,
            /*_src: display source for current widget,*/
            /*_progress: uploading status,*/
          };

          this.notifyPath('photoList.' + (this.push('photoList',image)-1));
          MGAPP.set(['items',itemKey,'images',imgKey], {name: imgName, rep: repKey, thumbnail: thumbKey});

          let thumbnail = new Image();
          let canvas = document.createElement('canvas');

          thumbnail.onload = (e) => {
            let size = (250*250);
            let w = Math.ceil(Math.sqrt(size * thumbnail.width / thumbnail.height));
            let h = Math.ceil(size / w);

            canvas.width = w;
            canvas.height = h;
            canvas.getContext('2d').drawImage(thumbnail, 0, 0, w, h);
            let dataURL = canvas.toDataURL('image/jpeg');

            this._setPhotoThumbnail(thumbKey,dataURL);

            canvas.toBlob(blob => {

              MGAPP.registerRepresentation(storageRef.child(thumbKey) , (key,ev,val) => {
                switch(ev) {
                  case 'complete': {
                    var registerData = {};

                    registerData['representations/'+key+'/uid'] = uid;
                    /* This will contain customizations like ROIs, thumbnail, custom name */
                    registerData['home/'+uid+'/items/'+itemKey+'/images/'+imgKey+'/thumbnail'] = key;
                    /* Published item, Will also contain tags */

                    MGAPP.DB.ref().update(registerData, error => {
                      if (!error) {
                        console.log("registered thumbnail", key);
                      } else {
                        console.error("ERR",error);
                      }
                    });
                  } break;
                }
              }, blob);

            },'image/jpeg',0.8);
          };

          MGAPP.registerRepresentation(storageRef.child(repKey) , (key,ev,val) => {
            switch(ev) {
              case 'progress': {
                this._setPhotoKeyProperty(imgKey, '_progress', (val.bytesTransferred / val.totalBytes * 100).toFixed(2));
              } break;
              case 'complete': {
                var registerData = {};

                registerData['representations/'+key+'/uid'] = uid;
                /* This will contain customizations like ROIs, thumbnail, custom name */
                registerData['home/'+uid+'/items/'+itemKey+'/images/'+imgKey+'/rep'] = key;
                registerData['home/'+uid+'/items/'+itemKey+'/images/'+imgKey+'/name'] = imgName;
                /* Published item, Will also contain tags */

                MGAPP.DB.ref().update(registerData, error => {
                  if (!error) {
                    console.log("registered", imgFile.name);
                  } else {
                    console.error("ERR",error);
                  }
                });
              } break;
              case 'src':
                thumbnail.src = val;
                //this._setPhotoKeyProperty(image.key,'_src',val);

                break;
              /* case 'task':
                 XXX Save task for cancellation.
               */
            }

          }, imgFile);

          MGAPP.set(['representations',repKey,'name'], imgFile.name);

        },this); /*forEach(files)*/
      }

      _filesSelected(e) {
        let files = e.target.files;

        if (!files || !files.length) {
          return;
        }

        let itemKey = this.itemKey;
        let uid = MGAPP.AU.currentUser.uid;
        let role = this.itemRole;
        let name = this.itemName;

        console.assert(role, "Role is missing");

        if (!MGAPP.items[itemKey]) {
          MGAPP.set('items.'+itemKey, {
            _uid: uid,
            name: name,
            role: role,
            time: firebase.database.ServerValue.TIMESTAMP,
            images: {},
          });
        }

        var registerData = {};
        registerData['home/'+uid+'/items/'+itemKey+'/role'] = role;
        registerData['home/'+uid+'/items/'+itemKey+'/name'] = name;
        registerData['items/'+itemKey+'/uid'] = uid;
        registerData['items/'+itemKey+'/role'] = role;
        registerData['items/'+itemKey+'/name'] = name;
        registerData['items/'+itemKey+'/public'] = false;

        /* XXX Update server to allow swiching back to uploading task(s).
        This should push a tmp entry in mg-items */
        MGAPP.DB.ref().update(registerData, error => {
          if (!error) {
            this._LastWritten.uid = uid;
            this._LastWritten.name = name;
            this._LastWritten.role = role;
          }
        });

        this._uploadReps(uid,itemKey,files);
      }

      _onItemSnapshot(snapshot) {
        let itemKey = snapshot.key;
        let v = snapshot.val();

        this.set('loading', false);

        if (v) {

          if (!v.role) {
            /* If files got uploaded beforehand */
            return;
          }

          if (MGAPP.items[itemKey]) {
            MGAPP.set(['items',itemKey,'name'], v.name);
            MGAPP.set(['items',itemKey,'role'], v.role);
            MGAPP.set(['items',itemKey,'time'], v.time);
            MGAPP.set(['items',itemKey,'_uid'], snapshot.ref.parent.parent.key);
            /*
            for(let imgKey in v.images) {
              MGAPP.set(['items',itemKey,'images',imgKey], v.images[imgKey]);
            }
            */
          } else {
            MGAPP.set('items.'+itemKey, {
              _uid: snapshot.ref.parent.parent.key,
              name: v.name,
              role: v.role,
              time: v.time,
              images: {},
              /*images: v.images || {},*/
            });
          }
        } else if (!this.itemRole) {
          /* This is not creating a new item, just reset url & return */
          this.set('itemKey', null);
          return;
        } else if (!v) {
          /* Creating a new item */
          return;
        }

        /* Continue updating UI only if it's a snapshot of current item */
        if (snapshot.key != this.itemKey) {
          return;
        }

        /* Updating UI. Check against current key */

        this.set('itemRole',v.role);
        this.set('itemName',this._ItemName = v.name);

        let storageRef = MGAPP.ST.ref('home').child(MGAPP.AU.currentUser.uid).child('representations');


        /* Sort unsynced (uploading in progress) images after server's entries. */
        let images = Object.assign({}, MGAPP.items[this.itemKey].images);
        let entries = [];

        snapshot.child('images').forEach(ref => {
          MGAPP.set(['items',itemKey,'images',ref.key],ref.val());
          entries.push([ref.key, ref.val()]);
          delete images[ref.key]; /* Filter server records */
        });
        /* Add local records */
        Object.entries(images).forEach( entry => entries.push(entry));

        entries.forEach(([imgKey,image,order],index) => {
            /* update current photoList */

            let idx = this._indexImage(imgKey);
            if (idx === -1) {

              if (snapshot.key == itemKey) {
                this.notifyPath('photoList.' + (
                  this.push('photoList', {
                      key: imgKey,
                      thumbnail: image.thumbnail,
                      name: image.name,
                      /* Assign indices which were sorted above as order */
                      order: image.order || (index+1),
                  }) - 1
                ));
              }

            } else { /* update current photo's event-value */
              this.photoList[idx].key = imgKey;
              if (image.thumbnail && (this.photoList[idx].thumbnail != image.thumbnail)) {
                  this.photoList[idx].thumbnail = image.thumbnail;
                  this.notifyPath(['photoList',idx,'thumbnail']);
              }
              if (image.name) {
                this.photoList[idx].name = image.name;
                this.notifyPath(['photoList',idx,'name']);
              }
              this.photoList[idx].order = image.order || order;
              this.notifyPath(['photoList',idx,'order']);
            }

            /* XXX Allow custom placeholder rep */
            if (image.thumbnail) {
              MGAPP.registerRepresentation(storageRef.child(image.thumbnail),
                (repKey,ev,value) => {
                  if (ev == 'src') {
                    this._setPhotoThumbnail(repKey,value);
                  }
                }
              );
            } else {
              /*XXX Can't control the size of placeholder */
              this._setPhotoKeyProperty(imgKey, '_src', 'images/logo-pumpkin-outline-grayout.svg');
            }
          }
        );

      }

      _getDataError(error) {
        console.error("ERR", error);
        this._ItemReference.off('value', this._onItemSnapshot, this);
        delete this._ItemReference;
      }

      _itemKeyChanged(user, itemKey) {
        this._LastWritten = {};

        delete this._LastTapIndex;
        if (this._ItemReference) {
          this._ItemReference.off('value', this._onItemSnapshot, this);
          delete this._ItemReference;
        }

        if (!user || !itemKey) {
          return;
        }


//        this.previousItems[itemKey] = this.previousItems[itemKey] || {};

        this._ItemName = "ไอเท็มไม่มีชื่อ";
        this.set('itemName',this._ItemName);

        if (this.selectedImages) {
          this.splice('selectedImages',0,this.selectedImages.length);
        }
        this.set('photoList',[]);
        this.set('loading', true);
        this._ItemReference = MGAPP.DB.ref('home').child(MGAPP.AU.currentUser.uid)
                                      .child('items').child(itemKey);
        this._ItemReference.on('value', this._onItemSnapshot, this._getDataError, this);
      }

      _itemNameChanged(user, itemRole, itemName) {
        if (!user || !itemRole || (itemName == this._ItemName)) {
          return;
        }

        if (itemName) {

          delete this._ItemName;
          var registerData = {};
          registerData['items/'+this.itemKey+'/uid'] = user.uid;
          registerData['items/'+this.itemKey+'/name'] = itemName;
          registerData['items/'+this.itemKey+'/role'] = this.itemRole;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/name'] = itemName;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/role'] = itemRole;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/time'] = firebase.database.ServerValue.TIMESTAMP;

          this._LastWritten.uid = user.uid;
          this._LastWritten.name = itemName;
          this._LastWritten.role = this.itemRole;

          MGAPP.DB.ref().update(registerData, function(error){
            if (error) {
              console.error("ERR",error);
            }
          });
        }
      }

      _formatSize(bytes) {
        const base = 1024;
        const unit = ~~(Math.log(bytes) / Math.log(base));
        const dec = Math.max(0, Math.min(3, unit - 1));
        const size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
        return size + ' ' + ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'][unit];
      }

      _iconForRole(role) {
        return MGIconForRole(role);
      }

      _onAddButtonTap(e) {
        this.$.fileInput.value = '';
        this.$.fileInput.click();
      }

      _onReorderButtonTap(e) {
        let registerData = {};
        let autoNumber = this.selectedImages.length;
        this.photoList
        .sort(function(a,b){
          let ao = a.order || Number.MAX_SAFE_INTEGER;
          let bo = b.order || Number.MAX_SAFE_INTEGER;
          return ao-bo;
        })
        .forEach(function(photo){
          /* XXX Is it safe to update data for photos being uploaded?
           * Should it instantly update database before storage task finish?
           */
          registerData['home/'+MGAPP.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+photo.key+'/order'] = photo._selectionOrder || ++autoNumber;
        },this);

        MGAPP.DB.ref().update(registerData, error => {
          console.assert(!error,"ERR updating order");
        });
        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onDeleteButtonTap(e) {
        let registerData = {};

        photo._selectionOrder.forEach(function(key){
          registerData['home/'+MGAPP.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+photo.key+'/delete'] = true
        },this);

        MGAPP.DB.ref().update(registerData, error => {
            console.assert(!error,"ERR updating deletion");
        });
        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onCancelButtonTap(e) {
          this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onDeletePhoto(e) {
        console.log("e",e.model.index);
      }

      _shouldOpen(id) {
        if (id) return true;
        return false;
      }

      newItem(role,name) {
        let key = MGAPP.DB.ref('items').push().key;
        this.set('itemRole', role);
        this.set('itemKey', key);
         /* Only update UI name without server registration */
        this.set('itemName', this._ItemName = name || "แกลเลอรี่ไม่มีชื่อ");
      }

    }

    customElements.define(MGItem.is, MGItem);
  </script>
</dom-module>
