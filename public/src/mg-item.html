<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

/* XXX Make item behavior */
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-input.html">
<link rel="import" href="mg-item-image.html">


<dom-module id="mg-item">
  <template strip-whitespace>
      <custom-style>
    <style is="custom-style" include="mg-common-styles iron-flex iron-flex-alignment">
      :host {
      }

      .file-item {
        width: 100%;
        position: relative;
      }

      #selector {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        padding: 0px;
        height: 100%;
      }

      .image-icon {
        margin: 0 5px 5px 0;
        width: 120px;
        height: 120px;
      }

    </style>
      </custom-style>

    <iron-collapse class="vertical layout" opened="[[_shouldOpen(itemKey)]]">

      <div class="horizontal layout end">

        <template is="dom-if" if="{{loading}}">
          <img height="62px" src="images/logo-bounce.svg">
        </template>

        <template is="dom-if" if="{{!loading}}">

          <paper-input
            label="ชื่อแกลเลอรี่"
            focused="{{focusedName}}"
            always-float-label="[[focusedName]]"
            value="{{itemName}}"
          >
            <iron-icon icon="[[_iconForRole(itemRole)]]" slot="prefix"></iron-icon>
          </paper-input>

          <paper-button on-tap="_onAddButtonTap">
            <iron-icon icon="add"></iron-icon> เพิ่มรูป
          </paper-button>
          <template is="dom-if" if="{{hasSelection}}">
            <paper-button on-tap="_onDeleteButtonTap">
              <iron-icon icon="delete"></iron-icon> ลบ
            </paper-button>
            <paper-button on-tap="_onReorderButtonTap">
              <iron-icon icon="reorder"></iron-icon> เรียง
            </paper-button>
            <paper-button on-tap="_onAddButtonTap">
              <iron-icon icon="add-to-photos"></iron-icon> แกลเลอรี่
            </paper-button>
            <paper-button on-tap="_onCancelButtonTap">
              <iron-icon icon="cancel"></iron-icon> ยกเลิก
            </paper-button>
          </template>

        </template>

        <input type="file" id="fileInput" on-change="_filesSelected" hidden multiple>

      </div>

      <template is="dom-if" if="{{!photoList.0}}">
        <div class="vertical layout center center-justified" style="border-radius:5px;border:1px dashed tomato;width:100%;height:500px">
          แกลเลอรี่เปล่า ยังไม่มีรูป
        </div>
      </template>

      <iron-selector
        id="selector"
        attr-for-selected="key"
        selected-values="{{selectedImages}}"
        multi>

      <template is="dom-repeat" items="{{photoList}}" observe="order" sort="{{_reorderPhoto}}" mutable-data>

        <mg-item-image
          key="[[item.key]]"
          class="image-icon"
          src="[[item._src]]"
          progress="[[item._progress]]"
          label="[[item.name]]"
          selection-order="[[item._selectionOrder]]"
          icon="photo"
          transition="1.5s"
          spinner
          on-tap="_onItemTap"
        ></mg-item-image>

      </template>

      </iron-selector>

    </iron-collapse>

  </template>
  <script>
    class MGItem extends Polymer.Element {
      static get is() { return 'mg-item'; }

      static get properties() { return {
        files: Object,

        itemKey: {
          type: String,
          notify: true,
        },

        itemRole: {
          type: String,
        },

        itemName: {
          type: String,
          notify: true,
        },

        photoList: {
          type: Array,
          value: [],
        },

        selectedImages: {
          type: Array,
          notify: true,
        },

        hasSelection: Boolean,
      }}

      static get observers() { return [
        '_itemKeyChanged(me.user, itemKey)',
        '_itemNameChanged(me.user, itemRole, itemName)',
        '_selectedImagesChanged(selectedImages.splices)',
      ]}

      _reorderPhoto(a,b) {
        let ao = a.order || Number.MAX_SAFE_INTEGER;
        let bo = b.order || Number.MAX_SAFE_INTEGER;

        return ao-bo;
      }

      _selectedImagesChanged(changes) {
        if (changes) {
          let orderNumber = 0;
          /* Remove number from deselected photo */
          changes.indexSplices.forEach(splice => {
            splice.removed.forEach(removedKey => {
              this._setPhotoKeyProperty(removedKey,'_selectionOrder',null);
            })
          });

          this.selectedImages.forEach(key => {
            this._setPhotoKeyProperty(key,'_selectionOrder',++orderNumber);
          });
        }
        if (this.selectedImages.length) {
          this.set('hasSelection', true);
        } else {
          this.set('hasSelection', false);
        }

        /*
        if (this._InsertRange) {
          delete this._InsertRange;
          let beginKey = this.selectedImages.length ?
          let beginIndex,endIndex;
          for(let i = 0, photo; photo = this.photoList[i]; ++i) {
            if ()
          }
        }
        */
      }

      _onItemTap(e) {
        if (e.detail.sourceEvent.shiftKey) {
          if (typeof(this._LastTapIndex) == "undefined") {
            this._LastTapIndex = -1;
          }

          let inc = this._LastTapIndex < e.model.index ? 1 : -1;

          for (let i = this._LastTapIndex + inc; inc > 0 ? i < e.model.index : i > e.model.index; i+=inc) {
            this.$.selector.selectIndex(i);
          }
        }
        this._LastTapIndex = e.model.index;
      }

      _indexImage(imageKey) {
        /* XXX optimize later
        if (!this._ImageMap) {
          this._ImageMap = newMap();
        }

        let idx = this._ImageMap.get(imageKey);
        if (this.photoList.length > idx &&  this.photoList[idx].key == imageKey) {
          return idx;
        }
        */

        for (let i = 0, data; data = this.photoList[i]; ++i) {
          //this._ImageMap.set(data.key, i);
          if (data.key == imageKey) {
            return i;
          }
        }
        return -1;
      }

      _setPhotoKeyProperty(key,prop,val) {
        let idx = this._indexImage(key);
        if (idx !== -1) {
          this.photoList[idx][prop] = val;
          this.notifyPath(['photoList',idx,prop]);
        }
      }

      _setPhotoRepProperty(repKey,prop,val) {
        for (let i = 0, data; data = this.photoList[i]; ++i) {
          if (data.rep == repKey) {
            this.photoList[i][prop] = val;
            this.notifyPath(['photoList',i,prop]);
          }
        }
      }

      _uploadReps(uid,itemKey,files) {
        let storageRef = MGAPP.ST.ref('home').child(MGAPP.AU.currentUser.uid).child('representations');
        Array.from(files).forEach(function(imgFile){
          let repKey = MGAPP.DB.ref('representations').push().key;
          /* An item image would contain link(s) to storage image representation. */
          let image = {
            key: MGAPP.DB.ref('home').child(uid).child(itemKey).push().key,
            rep: repKey, /* db representations/repKey contains storage info eg. uid */
            name: imgFile.name.split('.')[0],
            /*_src: display source for current widget,*/
            /*_progress: uploading status,*/
          };

          this.notifyPath('photoList.' + (this.push('photoList',image)-1));
          MGAPP.set(['items',itemKey,'images',image.key], {name: image.name, rep: repKey});

          /* XXX Should generate a thumbnail representation with Pica */
          MGAPP.registerRepresentation(repKey ? storageRef.child(repKey):null , (key,ev,val) => {
            /*
            let thumb = new Image();
            thumb.onload = function(e) {
              let size = (300*300);
              let w = Math.ceil(Math.sqrt(size * thumb.width / thumb.height));
              let h = Math.ceil(size / w);

              let canvas = document.createElement('canvas');
              canvas.width = w;
              canvas.height = h;
              console.log(w,h);
              canvas.getContext('2d').drawImage(thumb, 0, 0, w, h);
              this._setPhotoKeyProperty(image.key,'_src',canvas.toDataURL('image/jpeg'));
              let blob = canvas.toBlob(dataURL);
            }.bind(this);
            thumb.src = src;
            */

            switch(ev) {
              case 'progress': {
                this._setPhotoKeyProperty(image.key, '_progress', (val.bytesTransferred / val.totalBytes * 100).toFixed(2));
              } break;
              case 'complete': {
                var registerData = {};

                registerData['representations/'+repKey+'/name'] = imgFile.name;
                /* This will contain customizations like ROIs, thumbnail, custom name */
                registerData['home/'+uid+'/items/'+itemKey+'/images/'+image.key+'/rep'] = repKey;
                registerData['home/'+uid+'/items/'+itemKey+'/images/'+image.key+'/name'] = image.name;
                /* Published item, Will also contain tags */

                MGAPP.DB.ref().update(registerData, (error) => {
                  if (!error) {
                    console.log("registered", imgFile.name);
                  } else {
                    console.error("ERR",error);
                  }
                });
              } break;
              case 'src':
                this._setPhotoKeyProperty(image.key,'_src',val);
                break;
              /* case 'task':
                 XXX Save task for cancellation.
               */
            }

          }, imgFile);

          MGAPP.set(['representations',repKey,'name'], imgFile.name);

        },this); /*forEach(files)*/
      }

      _filesSelected(e) {
        let files = e.target.files;

        if (!files || !files.length) {
          return;
        }

        let itemKey = this.itemKey;
        let uid = MGAPP.AU.currentUser.uid;
        let role = this.itemRole;
        let name = this.itemName;

        console.assert(role, "Role is missing");

        if (!MGAPP.items[itemKey]) {
          MGAPP.set('items.'+itemKey, {
            _uid: uid,
            name: name,
            role: role,
            time: firebase.database.ServerValue.TIMESTAMP,
            images: {},
          });
        }

        var registerData = {};
        registerData['home/'+uid+'/items/'+itemKey+'/role'] = role;
        registerData['home/'+uid+'/items/'+itemKey+'/name'] = name;
        registerData['items/'+itemKey+'/uid'] = uid;
        registerData['items/'+itemKey+'/role'] = role;
        registerData['items/'+itemKey+'/name'] = name;
        registerData['items/'+itemKey+'/public'] = false;

        /* XXX Update server to allow swiching back to uploading task(s).
        This should push a tmp entry in mg-items */
        MGAPP.DB.ref().update(registerData, (error) => {
          if (!error) {
            this._LastWritten.uid = uid;
            this._LastWritten.name = name;
            this._LastWritten.role = role;
          }
        });

        this._uploadReps(uid,itemKey,files);
      }

      _getItemSnapshot(snapshot) {
        let itemKey = snapshot.key;
        let v = snapshot.val();

        this.set('loading', false);

        if (v) {

          if (!v.role) {
            /* If files got uploaded beforehand */
            return;
          }

          if (MGAPP.items[itemKey]) {
            MGAPP.set(['items',itemKey,'name'], v.name);
            MGAPP.set(['items',itemKey,'role'], v.role);
            MGAPP.set(['items',itemKey,'time'], v.time);
            MGAPP.set(['items',itemKey,'_uid'], snapshot.ref.parent.parent.key);
            for(let imgKey in v.images) {
              MGAPP.set(['items',itemKey,'images',imgKey], v.images[imgKey]);
            }
          } else {
            MGAPP.set('items.'+itemKey, {
              _uid: snapshot.ref.parent.parent.key,
              name: v.name,
              role: v.role,
              time: v.time,
              images: v.images || {},
            });
          }
        } else if (!this.itemRole) {
          /* This is not creating a new item, just reset url & return */
          this.set('itemKey', null);
          return;
        } else if (!v) {
          /* Creating a new item */
          return;
        }

        /* Continue updating UI only if it's a snapshot of current item */
        if (snapshot.key != this.itemKey) {
          return;
        }

        /* Updating UI. Check against current key */

        this.set('itemRole',v.role);
        this.set('itemName',this._ItemName = v.name);

        let storageRef = MGAPP.ST.ref('home').child(MGAPP.AU.currentUser.uid).child('representations');

        Object.entries(MGAPP.items[this.itemKey].images)
        .sort(function(a,b){
          let ao = a[1].order || Number.MAX_SAFE_INTEGER;
          let bo = b[1].order || Number.MAX_SAFE_INTEGER;
          if (ao != bo) { return ao - bo; }
          if (a[0] < b[0]){ return -1; }
          if (a[0] > b[0]){ return 1; }
          return 0;
        })
        .forEach(([imgKey,image]) => {
        //  for(let imgKey in appImages) {
            /* update current photoList */

            let idx = this._indexImage(imgKey);
            if (idx === -1) {

              if (snapshot.key == itemKey) {
                this.notifyPath('photoList.' + (
                  this.push('photoList', {
                      key: imgKey,
                      rep: image.rep,
                      name: image.name,
                      order: image.order,
                  }) - 1
                ));
              }

            } else { /* update current photo's event-value */
              this.photoList[idx].key = imgKey;
              this.photoList[idx].rep = image.rep;
              this.notifyPath(['photoList',idx,'rep']);
              this.photoList[idx].name = image.name;
              this.notifyPath(['photoList',idx,'name']);
              this.photoList[idx].order = image.order;
              this.notifyPath(['photoList',idx,'order']);
            }

            /* XXX Allow custom placeholder rep */
            MGAPP.registerRepresentation(
              image.rep ? storageRef.child(image.rep):null,
              (repKey,ev,value) => {
                if (ev == 'src') {
                  this._setPhotoRepProperty(repKey,'_src',value);
                }
              }
            );
          }
        );
      }

      _getDataError(error) {
        console.error("ERR", error);
        this._ItemReference.off('value', this._getItemSnapshot, this);
        delete this._ItemReference;
      }

      _itemKeyChanged(user, itemKey) {
        this._LastWritten = {};

        delete this._LastTapIndex;
        if (this._ItemReference) {
          this._ItemReference.off('value', this._getItemSnapshot, this);
          delete this._ItemReference;
        }

        if (!user || !itemKey) {
          return;
        }


//        this.previousItems[itemKey] = this.previousItems[itemKey] || {};

        this._ItemName = "ไอเท็มไม่มีชื่อ";
        this.set('itemName',this._ItemName);

        if (this.selectedImages) {
          this.splice('selectedImages',0,this.selectedImages.length);
        }
        this.set('photoList',[]);
        this.set('loading', true);
        this._ItemReference = MGAPP.DB.ref('home').child(MGAPP.AU.currentUser.uid)
                                      .child('items').child(itemKey);
        this._ItemReference.on('value', this._getItemSnapshot, this._getDataError, this);
      }

      _itemNameChanged(user, itemRole, itemName) {
        if (!user || !itemRole || (itemName == this._ItemName)) {
          return;
        }

        if (itemName) {

          delete this._ItemName;
          var registerData = {};
          registerData['items/'+this.itemKey+'/uid'] = user.uid;
          registerData['items/'+this.itemKey+'/name'] = itemName;
          registerData['items/'+this.itemKey+'/role'] = this.itemRole;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/name'] = itemName;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/role'] = itemRole;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/time'] = firebase.database.ServerValue.TIMESTAMP;

          this._LastWritten.uid = user.uid;
          this._LastWritten.name = itemName;
          this._LastWritten.role = this.itemRole;

          MGAPP.DB.ref().update(registerData, function(error){
            if (error) {
              console.error("ERR",error);
            }
          });
        }
      }

      _formatSize(bytes) {
        const base = 1024;
        const unit = ~~(Math.log(bytes) / Math.log(base));
        const dec = Math.max(0, Math.min(3, unit - 1));
        const size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
        return size + ' ' + ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'][unit];
      }

      _iconForRole(role) {
        return MGIconForRole(role);
      }

      _onAddButtonTap(e) {
        this.$.fileInput.value = '';
        this.$.fileInput.click();
      }

      _onReorderButtonTap(e) {
        let registerData = {};
        let autoNumber = this.selectedImages.length;
        this.photoList
        .sort(function(a,b){
          let ao = a.order || Number.MAX_SAFE_INTEGER;
          let bo = b.order || Number.MAX_SAFE_INTEGER;
          return ao-bo;
        })
        .forEach(function(photo){
          /* XXX Is it safe to update data for photos being uploaded?
           * Should it instantly update database before storage task finish?
           */
          registerData['home/'+MGAPP.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+photo.key+'/order'] = photo._selectionOrder || ++autoNumber;
        },this);

        MGAPP.DB.ref().update(registerData, error => {
          console.assert(!error,"ERR updating order");
        });
        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onDeleteButtonTap(e) {
        let registerData = {};

        photo._selectionOrder.forEach(function(key){
          registerData['home/'+MGAPP.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+photo.key+'/delete'] = true
        },this);

        MGAPP.DB.ref().update(registerData, error => {
            console.assert(!error,"ERR updating deletion");
        });
        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onCancelButtonTap(e) {
          this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onDeletePhoto(e) {
        console.log("e",e.model.index);
      }

      _shouldOpen(id) {
        if (id) return true;
        return false;
      }

      newItem(role,name) {
        let key = MGAPP.DB.ref('items').push().key;
        this.set('itemRole', role);
        this.set('itemKey', key);
         /* Only update UI name without server registration */
        this.set('itemName', this._ItemName = name || "แกลเลอรี่ไม่มีชื่อ");
      }

    }

    customElements.define(MGItem.is, MGItem);
  </script>
</dom-module>
