<!DOCTYPE html>
<!--
 .................................................................................................
:::BSDB'::BSDB'::BSDB':::::BSDB':::BSDBS'::BSDBS'::BSDB'::::BSD'::BSDBS'::BSDBS'::BSDB'::::::BSD'::
::BSDBSD BSDBSD :.BSDBS':BSDBS .:BSD ..BSD  ...BSD 'BSDBS':BSD .BSD ..BSD  ...BSD :BSDBS'::BSDB .::
::COPYRIGHT2017 ::.BS BSDB .BS :BSD .::.BSD :::.BSD :BS .BSDB .BSD .:::BSD ::::BSD :BS BSDB BS .:::
:::BSDSTYLEBSD .:::BS  BS .:BS :BSD ::::BSD ::::BSD :BS ::BSD :BSD :::::...::::BSD :BS :BS  BS ::::
::::.LICENSE .::::BSD .:..::BS 'BSD ::::BSD ::::BSD :BS :::BS :BSD ::BSDBS'::::BSD :BS ::..:BS ':::
:::::::BSD .::::BSDB .::::::BSD 'BSD'::BSD .:::BSD .BSD :::BSD':BSD'::.BSD :::BSD .BSD :::::BSDB'::
::::::::B .::::::BS .:::::::.BSD ::BSDBS .:BSDBS  :BSD .::::BSD :.BSDBS BS BSDB .:BSD .:::::.BS .::
`::::::::.::::::::..::::::::::...:::.....:::.....:::...::::::...:::.............:::...::::::::..::'
-->

/* XXX Make item behavior */
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/iron-collapse/iron-collapse.html">
<link rel="import" href="../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../bower_components/paper-input/paper-input.html">
<link rel="import" href="../bower_components/paper-progress/paper-progress.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="mg-common-styles.html">
<link rel="import" href="mg-input.html">
<link rel="import" href="mg-item-image.html">


<dom-module id="mg-item">
  <template strip-whitespace>
      <custom-style>
    <style is="custom-style" include="mg-common-styles iron-flex iron-flex-alignment">
      :host {
        min-height: 80vh;
        background-size: contain;
        background-repeat: no-repeat;
      }

      :host([empty]) {
        background-image: url(/images/logo-pumpkin-light.svg);
        border-radius: 5px;
      }

      .file-item {
        width: 100%;
        position: relative;
      }

      #selector {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        padding: 0px;
        height: 100%;
      }

      .image-icon {
        margin: 0 5px 5px 0;
        width: 120px;
        height: 120px;
      }

      .copied-icon {
        margin: 0 5px 5px 0;
        width: 80px;
        height: 80px;
      }

      .copied-collapse {
        background-color: white;
        border-radius: 5px;
        margin-bottom: 20px;
      }

      .copied-container {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        box-shadow: inset 1px 1px 1px var(--app-shadow-color);
        border-radius: 5px;
        padding: 5px;
        margin: 5px;
        background-color: rgba(0,0,0,0.02);
      }

      /*
      .cancel-copy-button {
        @apply(--layout-self-end);
        color:white;
        --iron-icon-stroke-color:rgba(0,0,0,0.2);
        pointer-events: none;
      }
      */

      .image-editor {
        width:100vw;
        height:100vh;
        position: fixed;
        top: 0;
        left: 0;
        z-index:1000;
        background-color: rgba(0,0,0,0.5);
      }

    </style>
      </custom-style>

      <!--
    <iron-collapse class="image-editor vertical layout" opened>
      xyz
    </iron-collapse>
  -->

    <iron-collapse class="vertical layout" opened="[[itemKey]]">

      <div class="horizontal layout end">

        <template is="dom-if" if="{{loading}}">
          <img height="62px" src="images/logo-bounce.svg">
        </template>

        <template is="dom-if" if="{{!loading}}">

          <paper-input
            label="ชื่อแกลเลอรี่"
            focused="{{focusedName}}"
            always-float-label="[[focusedName]]"
            value="{{itemName}}"
          >
            <iron-icon icon="[[_iconForRole(itemRole)]]" slot="prefix"></iron-icon>
          </paper-input>

          <paper-button on-tap="_onAddButtonTap">
            <iron-icon icon="add"></iron-icon> เพิ่มรูป
          </paper-button>
          <template is="dom-if" if="{{selectedImages.length}}">
            <paper-button on-tap="_onDeleteButtonTap">
              <iron-icon icon="delete"></iron-icon> ลบ
            </paper-button>
            <paper-button on-tap="_onReorderButtonTap">
              <iron-icon icon="reorder"></iron-icon> เรียง
            </paper-button>
            <paper-button on-tap="_onCopyButtonTap">
              <iron-icon icon="content-copy"></iron-icon> ก๊อปปี้
            </paper-button>
            <paper-button on-tap="_onEditButtonTap">
              <iron-icon icon="mode-edit"></iron-icon> แก้ไข
            </paper-button>
            <paper-button on-tap="_onCancelButtonTap">
              <iron-icon icon="cancel"></iron-icon> ยกเลิก
            </paper-button>
          </template>

        </template>

        <input type="file" id="fileInput" on-change="_filesSelected" hidden multiple>

      </div>

      <iron-collapse class="copied-collapse vertical layout" opened="[[clipboardList.length]]">

        <div class="copied-container">
          <template is="dom-repeat" items="{{clipboardList}}" mutable-data>

            <mg-item-image
              key="[[item.key]]"
              class="copied-icon"
              thumbnail="[[item.thumbnail]]"
              name="[[item.name]]"
              on-tap="_onCopiedTap"
            ><!--<iron-icon icon="cancel" class="cancel-copy-button"></iron-icon>--></mg-item-image>

          </template>
        </div>

        <div class="horizontal layout center-justified">
          <paper-button class="horizontal layout start-justified" on-tap="_onPasteClipboardTap">
            <iron-icon icon="content-paste"></iron-icon> เพิ่มลงแกลเลอรี่
          </paper-button>
          <paper-button class="horizontal layout start-justified" on-tap="_onClearClipboardTap">
            <iron-icon icon="cancel"></iron-icon> เคลียร์คลิปบอร์ด
          </paper-button>
        </div>
      </iron-collapse>

      <iron-selector
        id="selector"
        attr-for-selected="key"
        selected-values="{{selectedImages}}"
        multi>

      <!-- XXX Maybe sorting will cause ghost update -->
      <template is="dom-repeat" items="{{iconList}}" observe="order deleted" sort="{{_reorderPhoto}}" mutable-data>

        <mg-item-image
          key="[[item.key]]"
          class="image-icon"
          thumbnail="[[item.thumbnail]]"
          progress="[[item._progress]]"
          name="[[item.name]]"
          selection-order="[[item._selectionOrder]]"
          deleted="[[item.deleted]]"
          on-tap="_onItemTap"
        >
        </mg-item-image>

      </template>

      </iron-selector>

    </iron-collapse>

  </template>
  <script>
    class MGItem extends Polymer.Element {
      static get is() { return 'mg-item'; }

      static get properties() { return {
        files: Object,

        itemKey: {
          type: String,
          notify: true,
        },

        itemRole: {
          type: String,
        },

        itemName: {
          type: String,
          notify: true,
        },

        iconList: {
          type: Array,
          value: [],
        },

        clipboardList: {
          type: Array,
          value: [],
        },

        selectedImages: {
          type: Array,
        },

        empty: {
          type: Boolean,
          notify: true,
          reflectToAttribute: true,
        },
      }}

      static get observers() { return [
        '_itemKeyChanged(me.user, itemKey)',
        '_itemNameChanged(me.user, itemRole, itemName)',
        '_selectedImagesChanged(selectedImages.splices)',
        '_checkEmpty(iconList.length)',
      ]}

      _checkEmpty(len) {
        this.set('empty', len?false:true);
      }

      _reorderPhoto(a,b) {
        if (a.deleted) {
          if (b.deleted) {
            if (a.key < b.key) {
              return -1;
            }
          }
          return 1;
        }
        if (b.deleted) {
          return -1;
        }

        if (a.order) {
          if (b.order) {
            return a.order - b.order;
          }
          return -1;
        } else if (b.order) {
          return 1;
        }

        if (a.key < b.key) {
          return -1;
        }

        return 1;
      }

      _selectedImagesChanged(changes) {
        if (changes) {
          let orderNumber = 0;
          /* Remove number from deselected photo */
          changes.indexSplices.forEach(splice => {
            splice.removed.forEach(removedKey => {
              this._setPhotoKeyProperty(removedKey,'_selectionOrder',null);
            })
          });

          this.selectedImages.forEach(key => {
            this._setPhotoKeyProperty(key,'_selectionOrder',++orderNumber);
          });
        }
      }

      _onItemTap(e) {

        if (e.detail.sourceEvent.shiftKey) {
          if (typeof(this._LastTapIndex) == "undefined") {
            this._LastTapIndex = -1;
          }

          let inc = this._LastTapIndex < e.model.index ? 1 : -1;

          for (let i = this._LastTapIndex + inc; inc > 0 ? i < e.model.index : i > e.model.index; i+=inc) {
            this.$.selector.selectIndex(i);
          }
        }
        this._LastTapIndex = e.model.index;
      }

      _onEditButtonTap(e) {

      }

      _indexImage(imageKey,cb) {
        /* XXX optimize later
        if (!this._ImageMap) {
          this._ImageMap = newMap();
        }

        let idx = this._ImageMap.get(imageKey);
        if (this.iconList.length > idx &&  this.iconList[idx].key == imageKey) {
          return idx;
        }
        */

        for (let i = 0, data; data = this.iconList[i]; ++i) {
          //this._ImageMap.set(data.key, i);
          if (data.key == imageKey) {
            if (cb) { cb(i); }

            return i;
          }
        }
        return -1;
      }

      _setPhotoKeyProperty(key,prop,val) {
        let idx = this._indexImage(key);
        if (idx !== -1) {
          if (this.iconList[idx][prop] != val) {
            this.iconList[idx][prop] = val;
            this.notifyPath(['iconList',idx,prop]);
          }
        }
      }

      _uploadReps(uid,itemKey,files) {
        Array.from(files).forEach(imgFile => {
          let repKey = MGAPP.DB.ref('representations').push().key;
          let thumbKey = MGAPP.DB.ref('representations').push().key;
          let imageKey =  MGAPP.DB.ref('home').child(uid).child(itemKey).child('images').push().key;
          let imageName = imgFile.name.split('.')[0];
          let coverImageKey = MGAPP.get(['items',itemKey,'cover']) || imageKey;

          MGAPP.assignItem(itemKey,{ cover: coverImageKey });

          let registerInfo = {};
          function registerImageReps() {

            /* Update once thumbnail and rep are uploaded onto storage */
            if (registerInfo.thumbnail && registerInfo.rep) {
              let registerData = {
                ['representations/'+registerInfo.rep+'/uid']: uid,
                ['representations/'+registerInfo.thumbnail+'/uid']: uid,
                ['home/'+uid+'/items/'+itemKey+'/cover']: coverImageKey,
                ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/thumbnail']: registerInfo.thumbnail,
                ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/rep']: registerInfo.rep,
                ['home/'+uid+'/items/'+itemKey+'/images/'+imageKey+'/name']: registerInfo.name,
              }
              MGAPP.DB.ref().update(registerData, error => {
                if (!error) {
                } else {
                  console.error("ERR",error);
                }
              });
            }
          }

          /* Data for representing an image in the UI */
          let icon = {
            key: imageKey,
            thumbnail: thumbKey, /* db representations/repKey contains storage info eg. uid */
            name: imageName,
            rep: repKey,
            /*_progress: uploading status,*/
          };

          let thumbnailLoader = new Image();
          let canvas = document.createElement('canvas');

          thumbnailLoader.onload = (e) => {
            let area = (250*250); /* Default area for thumbnail */

            let w = Math.ceil(Math.sqrt(area * thumbnailLoader.width / thumbnailLoader.height));
            let h = Math.ceil(area / w);

            canvas.width = w;
            canvas.height = h;
            canvas.getContext('2d').drawImage(thumbnailLoader, 0, 0, w, h);
            let dataURL = canvas.toDataURL('image/jpeg');

            canvas.toBlob(blob => {

              /* Thumbnail's actual upload should start after finishing image upload */
              MGAPP.registerRepresentation(thumbKey, (key,ev,val) => {
                switch(ev) {
                  case 'src': {
                    MGAPP.assignItem(itemKey,{
                      images: {
                        [imageKey]: {
                          name: imageName,
                          thumbnail: thumbKey,
                        }
                      },
                    });

                  } break;
                  case 'complete': {

                    /* This will contain customizations like ROIs, thumbnail, custom name */
                    registerInfo.thumbnail = key;
                    /* Published item, Will also contain tags */
                    registerImageReps();

                  } break;
                }
              }, blob);
              this.notifyPath('iconList.' + (this.push('iconList',icon)-1));

            },'image/jpeg',0.8);
          };

          MGAPP.registerRepresentation(repKey, (key,ev,val) => {
            switch(ev) {
              case 'progress': {
                this._setPhotoKeyProperty(imageKey, '_progress', (val.bytesTransferred / val.totalBytes * 100).toFixed(2));
              } break;
              case 'complete': {

                MGAPP.assignItem(itemKey,{
                  images: {
                    [imageKey]: {
                      rep: repKey,
                    }
                  },
                });

                /* This will contain customizations like ROIs, thumbnail, custom name */
                registerInfo.rep = key;
                registerInfo.name = imageName;
                /* Published item, Will also contain tags */
                registerImageReps();

              } break;
              case 'src':
                thumbnailLoader.src = val;

                break;
              /* case 'task':
                 XXX Save task for cancellation.
               */
            }

          }, imgFile);

        }); /*forEach(files)*/
      }

      _filesSelected(e) {
        let files = e.target.files;

        if (!files || !files.length) {
          return;
        }

        let itemKey = this.itemKey;
        let uid = MGAPP.AU.currentUser.uid;
        let role = this.itemRole;
        let name = this.itemName;

        console.assert(role, "Role is missing");

        MGAPP.assignItem(itemKey,{
            _uid: uid,
            name: name,
            role: role,
            time: firebase.database.ServerValue.TIMESTAMP,
        });

        var registerData = {};
        registerData['home/'+uid+'/items/'+itemKey+'/role'] = role;
        registerData['home/'+uid+'/items/'+itemKey+'/name'] = name;
        registerData['items/'+itemKey+'/uid'] = uid;
        registerData['items/'+itemKey+'/role'] = role;
        registerData['items/'+itemKey+'/name'] = name;
        registerData['items/'+itemKey+'/public'] = false;

        MGAPP.DB.ref().update(registerData, error => { if (!error) {} });

        this._uploadReps(uid,itemKey,files);
      }

      _onItemSnapshot(snapshot) {
        let itemKey = snapshot.key;
        let v = snapshot.val();

        this.set('loading', false);

        if (v) {

          if (!v.role) {
            /* If files got uploaded beforehand */
            return;
          }

          MGAPP.assignItem(itemKey,{
              _uid: snapshot.ref.parent.parent.key,
              name: v.name,
              role: v.role,
              time: v.time,
              cover: v.cover,
          });

        } else if (!this.itemRole) {
          /* This is not creating a new item, just reset url & return */
          this.set('itemKey', null);
          return;
        } else if (!v) {
          /* Creating a new item */
          return;
        }

        /* Continue updating UI only if it's a snapshot of current item */
        if (snapshot.key != this.itemKey) {
          return;
        }

        /* Updating UI. Check against current key */

        this.set('itemRole',v.role);
        this.set('itemName',this._ItemName = v.name);

        let storageRef = MGAPP.ST.ref('UID').child(MGAPP.AU.currentUser.uid).child('DATA');


        /* Sort unsynced (uploading in progress) images after server's entries. */
        let images = Object.assign({}, MGAPP.items[this.itemKey].images);
        let entries = [];

        snapshot.child('images').forEach(ref => {
          let val = ref.val();
          val.deleted = val.deleted || null;
          MGAPP.assignItem(itemKey,{
            images:{
              [ref.key]: val,
            }
          });

          entries.push([ref.key, ref.val()]);
          delete images[ref.key]; /* Filter server records */
        });
        /* Add local records XXX seems bad cuz it didn't update local ? */
        Object.entries(images).forEach( entry => entries.push(entry));

        entries.forEach(([imageKey,image,order]) => {
            /* update current iconList */

            let idx = this._indexImage(imageKey);
            if (idx === -1) {

              if (snapshot.key == itemKey) {

                this.notifyPath('iconList.' + (
                  this.push('iconList', {
                      key: imageKey,
                      thumbnail: image.thumbnail,
                      rep: image.rep,
                      name: image.name,
                      order: image.order,
                      deleted: image.deleted,
                  }) - 1
                ));
              }

            } else { /* update current icon's event-value */
              this.iconList[idx].key = imageKey;
              /* Make sure dirty checks here are necessary */
              if (image.thumbnail && (this.iconList[idx].thumbnail != image.thumbnail)) {
                  this.iconList[idx].thumbnail = image.thumbnail;
                  this.notifyPath(['iconList',idx,'thumbnail']);
              }
              if (image.rep && (this.iconList[idx].rep != image.rep)) {
                this.iconList[idx].rep = image.rep;
                this.notifyPath(['iconList',idx,'rep']);
              }
              if (image.name) {
                this.iconList[idx].name = image.name;
                this.notifyPath(['iconList',idx,'name']);
              }
              this.iconList[idx].deleted = image.deleted ? true:false;
              this.notifyPath(['iconList',idx,'deleted']);

              this.iconList[idx].order = image.order || order;
              this.notifyPath(['iconList',idx,'order']);
            }

          }
        );

      }

      _getDataError(error) {
        console.error("ERR", error);
        this._ItemReference.off('value', this._onItemSnapshot, this);
        delete this._ItemReference;
      }

      _itemKeyChanged(user, itemKey) {

        delete this._LastTapIndex;
        if (this._ItemReference) {
          this._ItemReference.off('value', this._onItemSnapshot, this);
          delete this._ItemReference;
        }

        if (!user || !itemKey) {
          return;
        }

        this._ItemName = "ไอเท็มไม่มีชื่อ";
        this.set('itemName',this._ItemName);

        if (this.selectedImages) {
          this.splice('selectedImages',0,this.selectedImages.length);
        }

        this.iconList.forEach((icon,index) => {
          this.set(['iconList',index,'thumbnail'],null);
          this.notifyPath(['iconList',index,'thumbnail']);
        });

        this.set('iconList',[]);
        this.set('loading', true);
        this._ItemReference = MGAPP.DB.ref('home').child(MGAPP.AU.currentUser.uid)
                                      .child('items').child(itemKey);
        this._ItemReference.on('value', this._onItemSnapshot, this._getDataError, this);
      }

      _itemNameChanged(user, itemRole, itemName) {
        if (!user || !itemRole || (itemName == this._ItemName)) {
          return;
        }

        if (itemName || itemName === "") {

          delete this._ItemName;
          var registerData = {};
          registerData['items/'+this.itemKey+'/uid'] = user.uid;
          registerData['items/'+this.itemKey+'/name'] = itemName;
          registerData['items/'+this.itemKey+'/role'] = this.itemRole;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/name'] = itemName;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/role'] = itemRole;
          registerData['home/'+user.uid+'/items/'+this.itemKey+'/time'] = firebase.database.ServerValue.TIMESTAMP;

          MGAPP.DB.ref().update(registerData, function(error){
            if (error) {
              console.error("ERR",error);
            }
          });
        }
      }

      _formatSize(bytes) {
        const base = 1024;
        const unit = ~~(Math.log(bytes) / Math.log(base));
        const dec = Math.max(0, Math.min(3, unit - 1));
        const size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
        return size + ' ' + ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'][unit];
      }

      _iconForRole(role) {
        return MGIconForRole(role);
      }

      _onAddButtonTap(e) {
        this.$.fileInput.value = '';
        this.$.fileInput.click();
      }

      _onReorderButtonTap(e) {
        let registerData = {};
        let autoNumber = this.selectedImages.length;
        this.iconList
        .sort(function(a,b){
          let ao = a.order || Number.MAX_SAFE_INTEGER;
          let bo = b.order || Number.MAX_SAFE_INTEGER;
          return ao-bo;
        })
        .forEach(function(icon){
          /*XXX define cover properly*/
          if (icon._selectionOrder == 1) {
            registerData['home/'+MGAPP.AU.currentUser.uid+'/items/'+this.itemKey+'/cover'] = icon.key;
          }

          registerData['home/'+MGAPP.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+icon.key+'/order'] = icon._selectionOrder || ++autoNumber;
        },this);

        MGAPP.DB.ref().update(registerData, error => {
          console.assert(!error,"ERR updating order");
        });
        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onDeleteButtonTap(e) {
        let registerData = {};
        let selectedImages = this.selectedImages;

        this.selectedImages.forEach(selectedKey => {
          let del = MGAPP.get(['items',this.itemKey,'images',selectedKey,'deleted']) ? null:true;
          MGAPP.assignItem(this.itemKey, {images:{[selectedKey]:{deleted:del}}});
          registerData['home/'+MGAPP.AU.currentUser.uid+'/items/'+this.itemKey+'/images/'+selectedKey+'/deleted'] = del;
        });
        this.splice('selectedImages',0,this.selectedImages.length);

        MGAPP.DB.ref().update(registerData, error => {
            console.assert(!error,"ERR updating deletion");
        });
      }

      _onCancelButtonTap(e) {
          this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onCopiedTap(e) {
        this.splice('clipboardList',e.model.index,1);
      }

      _onCopyButtonTap(e) {
        this.selectedImages.forEach(imageKey => {
          this._indexImage(imageKey, idx => {
            let copy = {
              name: this.iconList[idx].name,
              thumbnail: this.iconList[idx].thumbnail,
              rep: this.iconList[idx].rep,
            };
            this.push('clipboardList', copy);
          });
        });

        this.splice('selectedImages',0,this.selectedImages.length);
      }

      _onClearClipboardTap(e) {
        this.splice('clipboardList',0,this.clipboardList.length);
      }

      _onPasteClipboardTap(e) {
        console.assert(this.clipboardList.length,"Empty clipboard?");

        let uid = MGAPP.AU.currentUser.uid;
        let itemKey = this.itemKey;
        let path = 'home/'+uid+'/items/'+itemKey;
        let ref = MGAPP.DB.ref('home').child(uid).child(itemKey).child('images');
        let registerData = {
          ['items/'+itemKey+'/public']: false,
          ['items/'+itemKey+'/uid']: uid,
          ['items/'+itemKey+'/role']: this.itemRole,
          ['items/'+itemKey+'/name']: this.itemName,
          [path+'/role']: this.itemRole,
          [path+'/name']: this.itemName,
        };

        path+='/images/';
        let coverKey = MGAPP.get(['items',itemKey,'cover']);
        this.clipboardList.forEach((data,index) => {
          let imageKey = ref.push().key;
          coverKey = coverKey || imageKey;
          registerData[path+imageKey+'/name'] = data.name || null;
          registerData[path+imageKey+'/thumbnail'] = data.thumbnail || null;
          registerData[path+imageKey+'/rep'] = data.rep || null;
        });

        registerData['home/'+uid+'/items/'+itemKey+'/cover'] = coverKey;

        /* XXX Should it also update local? Or should it rely only on query events? */
        /* XXX Need to try off-line. */

        MGAPP.DB.ref().update(registerData, error => {
          if (!error) {
          } else {
            console.error("ERR",error);
          }
        });
      }

      newItem(role,name) {
        let key = MGAPP.DB.ref('items').push().key;
        this.set('itemRole', role);
        this.set('itemKey', key);
         /* Only update UI name without server registration */
        this.set('itemName', this._ItemName = name || "แกลเลอรี่ไม่มีชื่อ");
      }

    }

    customElements.define(MGItem.is, MGItem);
  </script>
</dom-module>
